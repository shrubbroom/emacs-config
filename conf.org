#+TITLE: Configuration for Emacs
#+PROPERTY: header-args :results silent :tangle conf.el
#+BEGIN_SRC emacs-lisp
  ;;; conf.el --- Configuration generated by conf.org -*- lexical-binding: t; -*-
#+END_SRC
* Infrastructure
** Fire up packages!
   #+BEGIN_SRC emacs-lisp
     (package-initialize)
   #+END_SRC
** User defined actions
   User defined actions begin with ~init~.
*** Auto install packages
    #+BEGIN_SRC emacs-lisp
      (defun init/ensure-package (pkg)
        "ensure that package is installed, require it"
        (if (ignore-errors (require pkg))
            t
          (progn
            (unless (package-installed-p pkg)
              (package-refresh-contents)
              (package-install pkg))
            (unless (ignore-errors (require pkg))
              nil
              ;; (warn (format "(init/ensure-package) feature %s doesn't exist" pkg))
              )
            nil)))
      (defun init/ensure-package-lazy (pkg)
        "ensure package is installed, donot require"
        (unless (package-installed-p pkg)
          (package-refresh-contents)
          (package-install pkg)))
    #+END_SRC
*** Toggle sudo in a buffer
    #+BEGIN_SRC emacs-lisp
      (require 'tramp)
      (defun init/toggle-sudo-in-current-buffer ()
        (interactive)
        (if (buffer-file-name)
            (let ((sudo-buffer (current-buffer)))
              (progn
                (find-file (concat "/sudo:root@localhost:/" (buffer-file-name)))
                (kill-buffer sudo-buffer)))))
    #+END_SRC
*** Find ~init.el~
    #+BEGIN_SRC emacs-lisp
      (defun init/find-init ()
        (interactive) (find-file "~/.config/emacs/init.el"))
    #+END_SRC
*** Find ~conf.org~
    #+BEGIN_SRC emacs-lisp
      (defun init/find-conf ()
        (interactive) (find-file "~/.config/emacs/conf.org"))
    #+END_SRC
*** Open file in external applications
    #+BEGIN_SRC emacs-lisp
      (defun init/open-file-in-external-application (&optional args)
        (interactive)
        (ivy-read "App: "
                  '("Thunar" "Code" "Zathura")
                  :action #'open-file-in-external-application-action))
      (defun open-file-in-external-application-action (arg)
        (if (buffer-file-name)
            (pcase arg
              ("Thunar" (async-shell-command (concat "thunar " "\"" default-directory "\"")))
              ("Code" (async-shell-command (concat "code " "\"" (buffer-file-name) "\"")))
              ("Zathura" (async-shell-command (concat "za " "\"" (buffer-file-name) "\""))))
          (message "The buffer is not a file")))
    #+END_SRC
*** Toggle proxy
    #+BEGIN_SRC emacs-lisp :tangle (if (boundp 'init/local-proxies) "yes" "no")
      (defun init/toggle-url-proxy ()
        "Toggle proxy for the url.el library."
        (interactive)
        (cond
         (url-proxy-services
          (message "Turn off URL proxy")
          (setq url-proxy-services nil))
         (t
          (message "Turn on URL proxy")
          (setq url-proxy-services init/local-proxies))))
    #+END_SRC
** Default behaviors
*** Use 4 spaces instead of tab
    #+BEGIN_SRC emacs-lisp
      (setq-default indent-tabs-mode nil)
    #+END_SRC
*** Save cursor position in file
    #+BEGIN_SRC emacs-lisp
      (save-place-mode)
    #+END_SRC
*** Go to first char instead of line head
    #+BEGIN_SRC emacs-lisp
      (defun smart-beginning-of-line ()
        "Move point to first non-whitespace character or beginning-of-line.
      Move point to the first non-whitespace character on this line.
      If point was already at that position, move point to beginning of line."
        (interactive)
        (let ((oldpos (point)))
          (back-to-indentation)
          (and (= oldpos (point))
               (beginning-of-line))))
      (global-set-key [home] 'smart-beginning-of-line)
      (global-set-key "\C-a" 'smart-beginning-of-line)
    #+END_SRC
*** Enable CUA mode
    #+BEGIN_SRC emacs-lisp
      (setq cua-delete-selection t)
      (cua-selection-mode t)
    #+END_SRC
*** Revert buffer in daemon-client mode
    #+BEGIN_SRC emacs-lisp :tangle (if (eq system-type 'darwin) "no" "yes")
      (advice-add #'save-buffers-kill-terminal :before
                  (lambda (&optional args)
                    (interactive) (setq client-revert-bufferp (current-buffer))))
      (defun client-revert-buffer ()
        "revert the buffer if client-revert-bufferp is defined and its buffer still lives"
        (interactive)
        (if (and (boundp 'client-revert-bufferp) (buffer-live-p client-revert-bufferp))
            (switch-to-buffer client-revert-bufferp)))
      (add-hook 'server-after-make-frame-hook 'client-revert-buffer)
    #+END_SRC
*** Set frame title
    #+BEGIN_SRC emacs-lisp
      (setq frame-title-format '(:eval
                                 (buffer-name)))
    #+END_SRC
*** Disable visible warning and cursor
    #+BEGIN_SRC emacs-lisp
      (setq inhibit-splash-screen t)
      (setq visible-bell nil
            visible-cursor nil
            ring-bell-function 'ignore)
    #+END_SRC
*** Disable cursor blink
    #+BEGIN_SRC  emacs-lisp
      (blink-cursor-mode 0)
    #+END_SRC
*** Use y/n instead of yes/no
    #+BEGIN_SRC emacs-lisp
      (fset 'yes-or-no-p 'y-or-n-p)
    #+END_SRC
*** Disable annoying ~$FILENAME~~
    #+BEGIN_SRC emacs-lisp
      (setq make-backup-files nil)
    #+END_SRC
*** Setup initial buffer
    #+BEGIN_SRC emacs-lisp
      (setq-default initial-scratch-message "")
      (add-hook 'emacs-startup-hook (lambda ()
                                      (switch-to-buffer "*scratch*")
                                      (goto-char (point-min))
                                      (insert (concat ";; start up cost: "
                                                      (emacs-init-time)
                                                      "\n\n"))))
    #+END_SRC
*** Define path
    #+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'init/define-path) "yes" "no")
      (init/define-path)
    #+END_SRC
** Navigation & Searching system
*** Basic packages
    #+BEGIN_SRC emacs-lisp
      (init/ensure-package 'ivy)
      ;; (init/ensure-package 'swiper)
      (init/ensure-package-lazy 'ctrlf)
      (init/ensure-package 'counsel)
      (init/ensure-package 'ivy-prescient)
    #+END_SRC
*** Configure ivy
**** Hook at startup
     #+BEGIN_SRC emacs-lisp
       (add-hook 'after-init-hook 'ivy-mode)
     #+END_SRC
**** Default variables
     #+BEGIN_SRC emacs-lisp
       (setq-default ivy-use-virtual-buffers t
                     ivy-virtual-abbreviate 'fullpath
                     ivy-count-format ""
                     projectile-completion-system 'ivy
                     ivy-magic-tilde nil
                     ivy-dynamic-exhibit-delay-ms 150
                     ivy-use-selectable-prompt t)
     #+END_SRC
**** Issues
     Enable ~escape~ as quit in ivy
     #+BEGIN_SRC emacs-lisp
       (define-key ivy-minibuffer-map [escape] 'minibuffer-keyboard-quit)
     #+END_SRC
*** Config ctrlf
    #+BEGIN_SRC emacs-lisp
      (ctrlf-mode +1)
    #+END_SRC
*** Configure counsel
**** Hook at startup
     #+BEGIN_SRC emacs-lisp
       (add-hook 'after-init-hook 'counsel-mode)
     #+END_SRC
**** Default variables
     #+BEGIN_SRC emacs-lisp
       (setq-default counsel-mode-override-describe-bindings t
                     ivy-initial-inputs-alist '((Man-completion-table . "^")
                                                (woman . "^")))
     #+END_SRC

**** Keybinding
     #+BEGIN_SRC emacs-lisp
       (global-set-key (kbd "M-x") 'counsel-M-x)
     #+END_SRC

*** Configure ivy-prescient
    ~prescient~ is required for history look-up
    #+BEGIN_SRC emacs-lisp
      (ivy-prescient-mode)
      (prescient-persist-mode +1)
    #+END_SRC
** Project manager
   Install ~projectile~
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package 'projectile)
   #+END_SRC
   Enable ~projectile-mode~ by default
   #+BEGIN_SRC emacs-lisp
     (projectile-mode +1)
     (setq projectile-enable-caching t)
   #+END_SRC
   Keybindings
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-c p f") #'projectile-find-file)
     (global-set-key (kbd "C-c p b") #'projectile-switch-to-buffer)
     (global-set-key (kbd "C-c p C-b") #'projectile-ibuffer)
     (global-set-key (kbd "C-c p g") #'projectile-switch-project)
   #+END_SRC
** Helping System
*** Basic packages
    #+BEGIN_SRC emacs-lisp
      (init/ensure-package 'which-key)
      (init/ensure-package 'helpful)
    #+END_SRC
*** Configurations
    #+BEGIN_SRC emacs-lisp
      (which-key-mode 1)
      (setq counsel-describe-function-function #'helpful-callable
            counsel-describe-variable-function #'helpful-variable)
      (global-set-key (kbd "C-h k") #'helpful-key)
      (global-set-key (kbd "C-h d") #'helpful-at-point)
      (define-key helpful-mode-map (kbd "n") #'next-line)
      (define-key helpful-mode-map (kbd "p") #'previous-line)
      (define-key help-mode-map (kbd "n") #'next-line)
      (define-key help-mode-map (kbd "p") #'previous-line)
    #+END_SRC
** Window management
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package 'winum)
     (setq winum-auto-setup-mode-line nil)
     (add-hook 'after-init-hook 'winum-mode)
   #+END_SRC
* Look and feel
  *This part should not be changed frequently. Spend time on important things*
** Fonts
   Use Sarasa Term SC as default font, the font size configuration is moved to ~local-variables.el~
   #+BEGIN_SRC emacs-lisp
     (set-frame-font "Junicode" nil t)
     (set-frame-font "Fantasque Sans Mono" nil t)
     (dolist (charset '(kana han cjk-misc bopomofo))
       (set-fontset-font (frame-parameter nil 'font) charset
                         (font-spec :family "LXGW WenKai")))
   #+END_SRC
*** prog-mode font
    Use separate font for ~prog-mode~
    #+BEGIN_SRC emacs-lisp
      (defface cc-font
        '((t :family "Fantasque Sans Mono"))
        "Fantasque Sans Mono"
        :group 'basic-faces)
      (dolist (hook '(eshell-mode-hook prog-mode-hook))
        (add-hook hook
                  #'(lambda ()
                      (if (display-graphic-p)
                          (progn
                            ;; (text-scale-set 1)
                            (set (make-local-variable 'buffer-face-mode-face) 'cc-font)
                            (buffer-face-mode t))))))
    #+END_SRC
** Ligature
*** MasOS
    #+BEGIN_SRC emacs-lisp :tangle (if (eq system-type 'darwin) "yes" "no")
      (mac-auto-operator-composition-mode +1)
    #+END_SRC
*** Linux
    #+begin_src emacs-lisp :tangle (if (eq system-type 'gnu/linux) "yes" "no")
      (add-to-list 'load-path
                   (concat user-emacs-directory "site-packages/ligature"))
      (require 'ligature)
      (ligature-set-ligatures 't '("www"))
      ;; Enable traditional ligature support in eww-mode, if the
      ;; `variable-pitch' face supports it
      (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
      ;; Enable ligature in other documentation mode
      (dolist (mode '(org-mode markdown-mode))
        (ligature-set-ligatures mode '("ff" "fi" "ffi")))
      ;; Enable all Fantasque Sans Mono ligatures in programming modes
      (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--"
                                           "####" "~~>" "***" "||=" "||>"
                                           ":::" "::=" "=:=" "===" "==>"
                                           "=!=" "=>>" "=<<" "=/=" "!=="
                                           "!!." ">=>" ">>=" ">>>" ">>-"
                                           ">->" "->>" "-->" "---" "-<<"
                                           "<~~" "<~>" "<*>" "<||" "<|>"
                                           "<$>" "<==" "<=>" "<=<" "<->"
                                           "<--" "<-<" "<<=" "<<-" "<<<"
                                           "<+>" "</>" "###" "#_(" "..<"
                                           "..." "+++" "/==" "///" "_|_"
                                           "www" "&&" "^=" "~~" "~@" "~="
                                           "~>" "~-" "**" "*>" "*/" "||"
                                           "|}" "|]" "|=" "|>" "|-" "{|"
                                           "[|" "]#" "::" ":=" ":>" ":<"
                                           "$>" "==" "=>" "!=" "!!" ">:"
                                           ">=" ">>" ">-" "-~" "-|" "->"
                                           "--" "-<" "<~" "<*" "<|" "<:"
                                           "<$" "<=" "<>" "<-" "<<" "<+"
                                           "</" "#{" "#[" "#:" "#=" "#!"
                                           "##" "#(" "#?" "#_" "%%" ".="
                                           ".-" ".." ".?" "+>" "++" "?:"
                                           "?=" "?." "??" ";;" "/*" "/="
                                           "/>" "//" "__" "~~" "(*" "*)"
                                           "\\\\" "://"))
      (global-ligature-mode t)
    #+end_src
** Smooth scrolling
   #+BEGIN_SRC emacs-lisp
     (setq scroll-margin 0)
     (setq scroll-step 1)
     (setq scroll-conservatively 101)
     (setq scroll-up-aggressively 0.01)
     (setq scroll-down-aggressively 0.01)
     (setq auto-window-vscroll nil)
     (setq fast-but-imprecise-scrolling nil)
     (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
     (setq mouse-wheel-progressive-speed nil)
     ;; Horizontal Scroll
     (setq hscroll-step 1)
     (setq hscroll-margin 0)
   #+END_SRC
** Theme
*** Issues
    We need to advice the theme changer so that theme can be completely changed in runtime.
    #+BEGIN_SRC emacs-lisp
      (defcustom load-theme-before-hook nil
        "Functions to run before load theme."
        :type 'hook)
      (defcustom load-theme-after-hook nil
        "Functions to run after load theme."
        :type 'hook)
      (defun load-theme-hook-wrapper (origin-func theme &rest args)
        "A wrapper of hooks around `load-theme'."
        (mapc #'disable-theme custom-enabled-themes)
        (run-hook-with-args 'load-theme-before-hook theme)
        (apply origin-func theme args)
        (run-hook-with-args 'load-theme-after-hook theme))
      (advice-add 'load-theme :around #'load-theme-hook-wrapper)
    #+END_SRC
*** Setup theme
    Install themes
    #+BEGIN_SRC emacs-lisp
      (init/ensure-package 'badwolf-theme)
      (init/ensure-package 'tao-theme)
      (add-to-list 'load-path
                   (concat user-emacs-directory "site-packages/moe-theme"))
      (require 'moe-theme)
    #+END_SRC
    Setup theme.
    #+BEGIN_SRC emacs-lisp :tangle (if (boundp 'init/theme-light) "yes" "no")
      (if (bound-and-true-p init/system-dark-modep)
          (load-theme init/theme-dark 1)
        (load-theme init/theme-light 1))
    #+END_SRC
*** Small modification to fringe color
    #+BEGIN_SRC emacs-lisp
      (defun init/tone-down-fringes ()
        (set-face-attribute 'fringe nil
                            :foreground (face-foreground 'default)
                            :background (face-background 'default)))
      (init/tone-down-fringes)
    #+END_SRC
** Icon
   Set up all-the-icons
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package 'all-the-icons)
   #+END_SRC
   I do not manually install the fonts of ~all-the-icons~. System package manager (~pacman~) maintains the font.
** Modeline
*** Install package
    #+BEGIN_SRC emacs-lisp
      (init/ensure-package 'doom-modeline)
    #+END_SRC
*** Set variables
    #+TODO: unicode fallback is broken.
    #+BEGIN_SRC emacs-lisp
      (setq doom-modeline-buffer-file-name-style 'buffer-name
            doom-modeline-project-detection 'projectile
            doom-modeline-modal-icon nil
            doom-modeline-icon t
            doom-modeline-unicode-fallback nil
            doom-modeline-mu4e nil
            doom-modeline-hud t
            all-the-icons-scale-factor 1.0)
      (set-face-background 'doom-modeline-bar "#859900" nil)
      (display-time-mode)
      (column-number-mode)
      (size-indication-mode)
    #+END_SRC
*** Fire up modeline
    #+BEGIN_SRC emacs-lisp
      (add-hook 'after-init-hook 'doom-modeline-mode)
    #+END_SRC
** Tabs
*** Sort-tab
    #+BEGIN_SRC emacs-lisp
      (add-to-list 'load-path
                   (concat user-emacs-directory "site-packages/sort-tab"))
      (require 'sort-tab)
      (sort-tab-mode +1)
      (global-set-key (kbd "<S-left>") 'sort-tab-select-prev-tab)
      (global-set-key (kbd "<S-right>") 'sort-tab-select-next-tab)
      (with-eval-after-load 'org
        (define-key org-mode-map (kbd "<S-left>") 'sort-tab-select-prev-tab)
        (define-key org-mode-map (kbd "<S-right>") 'sort-tab-select-next-tab))
      (add-to-list 'winum-ignored-buffers
                   "*sort-tab*")
      (defun sort-tab-refresh (&optional args)
        (interactive)
        (if sort-tab-mode
            (progn (sort-tab-mode -1)
                   (sort-tab-mode 1))))

    #+END_SRC
    Override hide behavior
    #+BEGIN_SRC emacs-lisp
      (advice-add 'sort-tab-buffer-need-hide-p
                  :around #'(lambda (origin buf)
                              (let ((name (buffer-name buf)))
                                (cond
                                 ((string-equal name "*eshell*")
                                  nil)
                                 ((string-equal name "TAGS")
                                  t)
                                 ((string-prefix-p "*eww" name)
                                  nil)
                                 (t (apply origin `(,buf)))))))

    #+END_SRC
*** Save and revert buffer state
    #+BEGIN_SRC emacs-lisp
      (defun sort-tab-get-session-and-kill-all-buffers ()
        (let* ((buffer-list (sort-tab-get-buffer-list))
               (session-list (mapcar #'(lambda (buf) (with-current-buffer buf
                                                       (if buffer-file-name
                                                           `("file" ,buffer-file-name ,sort-tab-buffer-freq)
                                                         (cond ((derived-mode-p 'eshell-mode)
                                                                `("eshell" ,(eshell/pwd) ,sort-tab-buffer-freq ,(buffer-name)))
                                                               ((derived-mode-p 'dired-mode)
                                                                `("dired" ,dired-directory ,sort-tab-buffer-freq))
                                                               (t nil)))))
                                     buffer-list)))
          (mapcar #'kill-buffer buffer-list)
          session-list))

      (defun sort-tab-revert-session (session-list)
        (mapcar #'(lambda (pair)
                    (let ((mode (car pair))
                          (file (cadr pair))
                          (freq (caddr pair)))
                      (cond ((equal mode "file") (with-current-buffer (find-file file)
                                                   (setq-local sort-tab-buffer-freq freq)))
                            ((equal mode "eshell") (let ((default-directory file))
                                                    (with-current-buffer (eshell 17)
                                                      (rename-buffer (cadddr pair))
                                                      (setq-local sort-tab-buffer-freq freq))))
                            ((equal mode "dired") (with-current-buffer (dired file)
                                                    (setq-local sort-tab-buffer-freq freq))))))
                session-list)
        (if sort-tab-mode
            (progn (sort-tab-mode -1)
                   (sort-tab-mode 1))))

      (defun act/save-session (session-file)
        "Save current session into a session file."
        (interactive
         (list (read-file-name "Session file to save: " "~/.emacs.d/sessions/")))
        (with-temp-file session-file
          (prin1 (sort-tab-get-session-and-kill-all-buffers) (current-buffer)))
        (switch-to-buffer "*scratch*"))

      (defun act/load-session (session-file)
        "Load session from session file, clear current session."
        (interactive
         (list (read-file-name "Session file to load: " "~/.emacs.d/sessions/")))
        (act/save-session "/dev/null")
        (sort-tab-revert-session
         (with-temp-buffer
           (insert-file-contents session-file)
           (cl-assert (eq (point) (point-min)))
           (read (current-buffer)))))

      (defun act/exchange-session (session-file)
        "Exchange session with session from file."
        (interactive
         (list (read-file-name "Session file to interchange: " "~/.emacs.d/sessions/")))
        (let ((session (with-temp-buffer
                         (insert-file-contents session-file)
                         (cl-assert (eq (point) (point-min)))
                         (read (current-buffer)))))
          (sort-tab-save-session session-file)
          (sort-tab-revert-session session)))

      (defun act/kill-session ()
        "Clear current session"
        (interactive)
        (act/save-session "/dev/null"))
    #+END_SRC
** Line number
   #+BEGIN_SRC emacs-lisp
     (add-hook 'prog-mode-hook 'display-line-numbers-mode)
   #+END_SRC
*** Tone down background, modify font
    #+BEGIN_SRC emacs-lisp
      (set-face-attribute 'line-number-current-line
                          nil
                          :weight 'bold
                          :height (face-attribute 'default :height)
                          :background (face-background 'line-number)
                          :foreground (face-background 'line-number-current-line)
                          :family "Fantasque Sans Mono")
      (set-face-attribute 'line-number
                          nil
                          :weight 'light
                          :height (face-attribute 'default :height)
                          :background (face-background 'default)
                          :family "Fantasque Sans Mono")
    #+END_SRC
** Popup control
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package 'popper)
     (init/ensure-package 'popper-echo)
     (setq popper-reference-buffers
           '("\\*Messages\\*"
             "Output\\*$"
             "\\*Async Shell Command\\*"
             help-mode
             helpful-mode
             compilation-mode
             Man-mode
             package-menu-mode
             pdf-outline-buffer-mode))
     (global-set-key (kbd "<C-tab>") 'popper-toggle-latest)
     (define-key popper-mode-map (kbd "<C-tab>") 'popper-cycle)
     (global-set-key (kbd "<C-escape>") 'popper-kill-latest-popup)
     (popper-mode +1)
     (popper-echo-mode +1)
   #+END_SRC
** Extra features
*** Rich ivy
    #+BEGIN_SRC emacs-lisp
      (init/ensure-package 'ivy-rich)
      (init/ensure-package 'all-the-icons-ivy-rich)
      (ivy-rich-mode 1)
      (all-the-icons-ivy-rich-mode 1)
      (setq ivy-rich-parse-remote-buffer nil)
    #+END_SRC
*** Brackets
**** Look
     #+BEGIN_SRC emacs-lisp
       (init/ensure-package 'rainbow-delimiters)
       (init/ensure-package 'highlight-parentheses)
     #+END_SRC
**** Display
     #+BEGIN_SRC emacs-lisp
       (add-hook 'prog-mode-hook #'show-paren-mode)
       (add-hook 'prog-mode-hook #'highlight-parentheses-mode)
     #+END_SRC
**** Smart parens
     #+BEGIN_SRC emacs-lisp
       (init/ensure-package 'smartparens)
       (add-hook 'after-init-hook 'smartparens-global-mode)
       (sp-pair "(" nil :unless '(sp-point-before-word-p))
       (sp-pair "[" nil :unless '(sp-point-before-word-p))
       (sp-pair "{" nil :unless '(sp-point-before-word-p))
       (sp-pair "\"" nil :unless '(sp-point-before-word-p))
       (sp-pair "\'" nil :unless '(sp-point-before-word-p))
       (sp-pair "`" nil :actions :rem)
     #+END_SRC
*** Display HEX/RGB color
    #+BEGIN_SRC emacs-lisp
      (init/ensure-package 'rainbow-mode)
    #+END_SRC
* Languages
** Completion system
*** Corfu
    Install ~corfu~ and globally enable corfu
    #+BEGIN_SRC emacs-lisp
      (init/ensure-package 'corfu)
      (init/ensure-package 'cape)
      (init/ensure-package 'yasnippet)
      (add-hook 'prog-mode-hook 'yas-minor-mode)
      (corfu-global-mode)
    #+END_SRC
    Configurations
    #+BEGIN_SRC emacs-lisp
      (setq corfu-auto t
            corfu-auto-prefix 1
            corfu-auto-delay 0
            corfu-quit-at-boundary t
            corfu-quit-no-match nil)
      (add-to-list 'completion-at-point-functions #'cape-file)
      (add-to-list 'completion-at-point-functions #'cape-tex)
      (add-to-list 'completion-at-point-functions #'cape-dabbrev)
      (add-to-list 'completion-at-point-functions #'cape-keyword)
      (setq dabbrev-ignored-buffer-regexps
            (rx (or (seq bos (any " *"))
                    (seq ".pdf" eos))))
    #+END_SRC
**** Enable Corfu in minibuffer
     #+BEGIN_SRC emacs-lisp
       (defun corfu-enable-in-minibuffer ()
         "Enable Corfu in the minibuffer if `completion-at-point' is bound."
         (when (where-is-internal #'completion-at-point (list (current-local-map)))
           (corfu-mode 1)))
       (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer)
     #+END_SRC
*** LSP
    Install ~lsp-mode~.
    #+BEGIN_SRC emacs-lisp
      (init/ensure-package-lazy 'lsp-mode)
    #+END_SRC
    Enable ~which-key~ help in ~lsp mode~.
    #+BEGIN_SRC emacs-lisp
      (add-hook 'lsp-mode-hook 'lsp-enable-which-key-integration)
    #+END_SRC
    We need to set ~idle-delay~ to tell LSP when it can update.
    #+BEGIN_SRC emacs-lisp
      (setq lsp-idle-delay 1)
    #+END_SRC
    Disable some annoying feature
    #+BEGIN_SRC emacs-lisp
      (setq lsp-diagnostic-package :none)
      (setq lsp-headerline-breadcrumb-enable nil)
      (setq lsp-lens-enable nil)
    #+END_SRC
    Disable default company completion provider
    #+BEGIN_SRC emacs-lisp
      (setq lsp-completion-provider :none)
      (defun init/lsp-mode-setup-completion ()
        (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
              '(flex)))
      (add-hook 'lsp-mode-hook #'init/lsp-mode-setup-completion)
    #+END_SRC
** Verilog
   Require built-in ~verilog-mode~.
   #+BEGIN_SRC emacs-lisp :tangle no
     (require 'verilog-mode)
   #+END_SRC
   Build completion system with ~ctags~ and ~company-keywords~.
   #+BEGIN_SRC emacs-lisp :tangle no
     (init/ensure-package 'citre)
     (setq verilog-imenu-generic-expression
           '(("*Outputs*" "^\\s-*\\(output\\)\\s-+\\(reg\\|wire\\|logic\\|\\)\\s-+\\(\\|\\[[^]]+\\]\\s-+\\)\\([A-Za-z0-9_]+\\)" 4)
             ("*Inputs*" "^\\s-*\\(input\\)\\s-+\\(reg\\|wire\\|logic\\|\\)\\s-+\\(\\|\\[[^]]+\\]\\s-+\\)\\([A-Za-z0-9_]+\\)" 4)
             (nil "^\\s-*\\(?:m\\(?:odule\\|acromodule\\)\\|p\\(?:rimitive\\|rogram\\|ackage\\)\\)\\s-+\\([a-zA-Z0-9_.:]+\\)" 1)
             ("*Wires*" "^\\s-*\\(wire\\)\\s-+\\(\\|\\[[^]]+\\]\\s-+\\)\\([A-Za-z0-9_]+\\)" 3)
             ("*Regs*" "^\\s-*\\(reg\\)\\s-+\\(\\|\\[[^]]+\\]\\s-+\\)\\([A-Za-z0-9_]+\\)" 3)
             ("*Parameters*" "^\\s-*\\(parameter\\)\\s-+\\([A-Za-z0-9_]+\\)" 2)
             ("*Instances*" "^\\s-*\\(?1:[A-Za-z0-9_]+\\)\\s-+\\1" 1)
             ("*Classes*" "^\\s-*\\(?:\\(?:virtual\\|interface\\)\\s-+\\)?class\\s-+\\([A-Za-z_][A-Za-z0-9_]+\\)" 1)
             ("*Tasks*" "^\\s-*\\(?:\\(?:static\\|pure\\|virtual\\|local\\|protected\\)\\s-+\\)*task\\s-+\\(?:\\(?:static\\|automatic\\)\\s-+\\)?\\([A-Za-z_][A-Za-z0-9_:]+\\)" 1)
             ("*Functions*" "^\\s-*\\(?:\\(?:static\\|pure\\|virtual\\|local\\|protected\\)\\s-+\\)*function\\s-+\\(?:\\(?:static\\|automatic\\)\\s-+\\)?\\(?:\\w+\\s-+\\)?\\(?:\\(?:un\\)signed\\s-+\\)?\\([A-Za-z_][A-Za-z0-9_:]+\\)" 1)
             ("*Interfaces*" "^\\s-*interface\\s-+\\([a-zA-Z_0-9]+\\)" 1)
             ("*Types*" "^\\s-*typedef\\s-+.*\\s-+\\([a-zA-Z_0-9]+\\)\\s-*;" 1)))
     (require 'company-keywords)
     (add-to-list 'company-keywords-alist (cons 'verilog-mode verilog-keywords))
     (defun company-citre (-command &optional -arg &rest _ignored)
       "Completion backend of Citre.  Execute COMMAND with ARG and IGNORED."
       (interactive (list 'interactive))
       (cl-case -command
         (interactive (company-begin-backend 'company-citre))
         (prefix (and (bound-and-true-p citre-mode)
                      (or (citre-get-symbol) 'stop)))
         (meta (citre-get-property 'signature -arg))
         (annotation (citre-capf--get-annotation -arg))
         (candidates (all-completions -arg (citre-capf--get-collection -arg)))
         (ignore-case (not citre-completion-case-sensitive))))

     (defun init/regenerate-tags ()
       (interactive)
       (if (and (boundp 'projectile-project-root)
                (projectile-project-root))
           (citre-update-this-tags-file t)
         ))
     (add-hook 'verilog-mode-hook (lambda ()
                                    (citre-auto-enable-citre-mode)
                                    (make-local-variable 'company-backends)
                                    (setq company-backends '((company-keywords
                                                              company-citre
                                                              )))
                                    (company-mode)
                                    ;; (make-local-variable 'after-save-hook)
                                    ;; (add-hook 'after-save-hook 'citre-update-this-tags-file)
                                    ))
     (add-to-list 'company-transformers #'delete-dups)
   #+END_SRC
** Python
*** Conda
    #+BEGIN_SRC emacs-lisp
      (init/ensure-package 'conda)
    #+END_SRC
    Setup conda
    #+BEGIN_SRC emacs-lisp
      (conda-env-initialize-eshell)
      (conda-env-activate 'base)
    #+END_SRC
*** Pyright
    ~yapf~ and ~pyright~ are used to format and complete.
    #+BEGIN_SRC emacs-lisp
      (init/ensure-package 'lsp-pyright)
      (defun lsp-pyright-format-buffer ()
        (interactive)
        (when (and (executable-find "yapf") buffer-file-name)
          (call-process "yapf" nil nil nil "-i" buffer-file-name "--style={COLUMN_LIMIT=256}")
          (revert-buffer t t)))
      (add-hook 'python-mode-hook
                #'(lambda ()
                    (lsp)
                    (add-hook 'after-save-hook #'lsp-pyright-format-buffer t t)))
      (when (executable-find "python3")
        (setq lsp-pyright-python-executable-cmd "python3"))
    #+END_SRC
** C/C++
   Installing ~ccls~ if ccls exists.
   #+BEGIN_SRC emacs-lisp :tangle (if (executable-find "ccls") "yes" "no")
     (init/ensure-package-lazy 'ccls)
     (setq ccls-sem-highlight-method nil)
   #+END_SRC
   Add lsp to cc-mode hook
   #+BEGIN_SRC emacs-lisp
     (dolist (hook '(c-mode-hook c++-mode-hook))
       (add-hook hook #'lsp))
   #+END_SRC
** Rust
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package 'rust-mode)
     (setq lsp-rust-server 'rust-analyzer)
     (setq lsp-rust-analyzer-cargo-watch-enable nil)
     (cl-defmethod lsp-clients-extract-signature-on-hover (contents (_server-id (eql rust-analyzer)))
       (-let* (((&hash "value") contents)
               (groups (--partition-by (s-blank? it) (s-lines (s-trim value))))
               (sig_group (if (s-equals? "```rust" (car (-third-item groups)))
                              (-third-item groups)
                            (car groups)))
               (sig (--> sig_group
                         (--drop-while (s-equals? "```rust" it) it)
                         (--take-while (not (s-equals? "```" it)) it)
                         (s-join "" it))))
         (lsp--render-element (concat "```rust\n" sig "\n```"))))

     (add-hook 'rust-mode-hook #'(lambda ()
                                   (setq-local compile-command "cargo build")
                                   (lsp)))
   #+END_SRC
** Emacs-Lisp
   Use ~paredit~ in ~elisp-mode~
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package 'paredit)
     (setq backward-delete-char-untabify-method 'all)
     (add-hook 'scheme-mode-hook 'paredit-mode)
     (add-hook 'scheme-mode-hook 'rainbow-delimiters-mode)
     (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
     (add-hook 'emacs-lisp-mode 'rainbow-delimiters-mode)
   #+END_SRC
** Shell
   Install ~fish-mode~ and config keybindings
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package 'fish-mode)
   #+END_SRC
** Matlab
   Install ~matlab-mode~
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package 'matlab-mode)
   #+END_SRC
** YAML
   Install ~yaml-mode~
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package 'yaml-mode)
   #+END_SRC
* Documentation
** Emacs Rime
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package-lazy 'rime)
     (with-eval-after-load 'rime
       (define-key rime-mode-map [escape] #'rime-inline-ascii)
       (advice-add 'rime-inline-ascii :after
                   #'(lambda () (if (rime--ascii-mode-p)
                                    (message "%s"
                                             (concat "rime inline ascii "
                                                     (propertize "enabled"
                                                                 :foreground
                                                                 "green")))
                                  (message "%s"
                                           (concat "rime inline ascii "
                                                   (propertize "disabled"
                                                               :foreground
                                                               "red")))))))
     ;; (define-key rime-mode-map (kbd "C-z") 'rime-force-enable)
     (setq default-input-method "rime")
     (setq rime-show-candidate 'posframe
           rime-librime-root (concat user-emacs-directory "librime/dist/")
           rime-user-data-dir (concat user-emacs-directory "rime/")
           rime-translate-keybindings
           '("C-f" "C-b" "C-n" "C-p" "C-g" "C-`")
           rime-show-preedit 'inline
           rime-disable-predicates
           '(
             rime-predicate-prog-in-code-p
             rime-predicate-org-in-src-block-p
             rime-predicate-current-uppercase-letter-p
             rime-predicate-after-alphabet-char-p
             rime-predicate-after-ascii-char-p
             rime-predicate-evil-mode-p
             rime-predicate-hydra-p
             rime-predicate-punctuation-line-begin-p
             rime-predicate-space-after-cc-p
             rime-predicate-tex-math-or-command-p))
   #+END_SRC
** Display
   Enable ~visual-line-mode~ in ~text-mode~ and Latex buffer.
   #+BEGIN_SRC emacs-lisp
     (add-hook 'text-mode-hook 'visual-line-mode)
     (dolist (hook '(TeX-mode-hook LaTeX-mode-hook bibtex-mode-hook))
       (add-hook hook visual-line-mode))
   #+END_SRC
** Org mode
*** Set seperate font for org mode
    #+BEGIN_SRC emacs-lisp
      (defface lm-font
        '((t :family "Junicode"))
        "LXGW Bright"
        :group 'basic-faces)
      (add-hook 'org-mode-hook
                #'(lambda ()
                    (if (display-graphic-p)
                        (progn
                          ;; (text-scale-set -1)
                          (set (make-local-variable 'buffer-face-mode-face)
                               'lm-font)
                          (buffer-face-mode t)
                          (face-remap-add-relative 'org-block '(:family "Fantasque Sans Mono"))))))
      (defun buffer-toggle-highlight-foreground (&optional args)
        (interactive)
        (if (and (boundp 'face-remap-add-relative-cookie) face-remap-add-relative-cookie)
            (progn (face-remap-remove-relative face-remap-add-relative-cookie)
                   (setq face-remap-add-relative-cookie nil))
          (set (make-local-variable 'face-remap-add-relative-cookie) (face-remap-add-relative 'default '(:foreground "#000000")))))
      (add-hook 'org-mode-hook #'buffer-toggle-highlight-foreground)
    #+END_SRC
*** Table Align
    #+BEGIN_SRC emacs-lisp
      (init/ensure-package-lazy 'valign)
      (if (display-graphic-p)
       (add-hook 'org-mode-hook #'valign-mode))
    #+END_SRC
*** Org Download
    #+BEGIN_SRC emacs-lisp
      (init/ensure-package-lazy 'org-download)
      (add-hook 'org-mode-hook 'org-download-enable)
    #+END_SRC
*** Org Superstar
    #+BEGIN_SRC emacs-lisp
      (init/ensure-package-lazy 'org-superstar)
      (add-hook 'org-mode-hook 'org-superstar-mode)
    #+END_SRC
*** Quick jump to specific headline via ivy and fuzzy search
    It will be helpful to jump quickly when editing ~conf.org~. Also see [[https://github.com/abo-abo/swiper/issues/986][discussion]].
    #+BEGIN_SRC emacs-lisp
      (setq org-goto-interface 'outline-path-completion)
      (setq org-outline-path-complete-in-steps nil)
    #+END_SRC
    I use ~"C-j"~ to invoke jump.
    #+BEGIN_SRC emacs-lisp
      (with-eval-after-load 'org
        (define-key org-mode-map (kbd "C-j") 'org-goto))
    #+END_SRC
*** Preview
    #+BEGIN_SRC emacs-lisp
      (with-eval-after-load 'org
        (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0)
              org-preview-latex-default-process 'dvisvgm))
      (init/ensure-package 'org-latex-impatient)
      (setq org-latex-impatient-tex2svg-bin
            "~/.local/mathjax-node/node_modules/mathjax-node-cli/bin/tex2svg")
    #+END_SRC
*** Word Wrap
    #+BEGIN_SRC emacs-lisp
      (add-hook 'org-mode-hook #'(lambda () (setq-local word-wrap-by-category t)))
    #+END_SRC
*** Local Functions
    #+BEGIN_SRC emacs-lisp
      (defun org-copy-src-block-link()
        (interactive)
        (save-excursion
          (forward-line -1)
          (org-edit-src-code)
          (clipboard-kill-ring-save (point-min) (point-max))
          (org-edit-src-exit)))
    #+END_SRC
*** Beautify
    #+BEGIN_SRC emacs-lisp
      (with-eval-after-load 'org
        ;; Make verbatim with highlight text background.
        (add-to-list 'org-emphasis-alist
                     '("=" (:background "#fef7ca")))
        ;; Make deletion(obsolote) text foreground with dark gray.
        (add-to-list 'org-emphasis-alist
                     '("+" (:foreground "dark gray"
                                        :strike-through t)))
        ;; Make code style around with box.
        (add-to-list 'org-emphasis-alist
                     '("~" (:box (:line-width 1
                                              :color "grey75"
                                              :style released-button))))
        (setq org-hide-emphasis-markers t
              org-pretty-entities t))

      (with-eval-after-load 'whitespace
        (dolist (face '(whitespace-space whitespace-tab whitespace-newline))
          (set-face-attribute face nil
                              :background (face-background 'default)
                              :foreground "grey75")))
      (setq whitespace-style '(face spaces tabs newline space-mark tab-mark newline-mark))
    #+END_SRC
*** Completion
    Disable auto completion provided by corfu
    #+begin_src emacs-lisp
      (with-eval-after-load 'org
        (require 'org-tempo))
      (add-hook 'org-mode-hook (lambda ()
                                 (setq-local corfu-auto nil)))
    #+end_src
*** Export
    #+begin_src emacs-lisp
      (add-hook 'org-mode-hook (lambda ()
                                 (setq-local compile-command
                                             (concat "pandoc --pdf-engine=xelatex --toc -V mainfont=\'LXGW Bright\' -o "
                                                     (concat (file-name-sans-extension (buffer-name)) ".pdf ")
                                                     (buffer-name)))))
      (setq org-latex-pdf-process
            '("xelatex -interaction=nonstopmode %f"
              "xelatex -interaction=nonstopmode %f"))
      (with-eval-after-load 'org
        (setq org-latex-default-packages-alist
              (remove '("AUTO" "inputenc" t)
                      org-latex-default-packages-alist)))
    #+end_src
*** Babel
    #+begin_src emacs-lisp
      (org-babel-do-load-languages 'org-babel-load-languages
                                   '((shell . t)
                                     (python . t)))
    #+end_src
** Latex
   #+BEGIN_SRC emacs-lisp
     ;; (setq org-latex-pdf-process
     ;;       '("xelatex -interaction --synctex=1 nonstopmode -output-directory %o %f"
     ;;         "xelatex -interaction --synctex=1 nonstopmode -output-directory %o %f"
     ;;         "xelatex -interaction --synctex=1 nonstopmode -output-directory %o %f"))
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((dot . t)))
     (init/ensure-package 'auctex)
     (setq TeX-auto-save t
           TeX-parse-self t
           TeX-source-correlate-mode t
           TeX-source-correlate-start-server t
           TeX-source-correlate-method '((dvi . source-specials)
                                         (pdf . synctex))
           ;; TeX-view-program-selection (quote
           ;;                             ((output-pdf "Zathura")
           ;;                              (output-dvi "Zathura")
           ;;                              (output-html "xdg-open")))
           )
     (setq-default TeX-master nil)
     (init/ensure-package 'lsp-latex)
     (dolist
         (hook '(TeX-mode-hook LaTeX-mode-hook bibtex-mode-hook))
       (add-hook hook #'(lambda ()
                          (add-to-list
                           'TeX-command-list
                           '("XeLaTeX" "%`xelatex%(mode)%' %t" TeX-run-TeX nil t))
                          (visual-line-mode)
                          (yas-minor-mode)
                          (setq-local lsp-diagnostics-provider :none)
                          (setq-local lsp-eldoc-enable-hover nil)
                          (setq-local lsp-modeline-diagnostics-enable nil)
                          (lsp))))
   #+END_SRC
* Extra features
** Set up magit
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package-lazy 'magit)
   #+END_SRC
** Eshell
*** Prompt
    #+BEGIN_SRC emacs-lisp
      (defun hex-to-hsl (hex)
        "Convert hex string to hsl digits, the result is returned as list"
        (eval `(color-rgb-to-hsl ,@(mapcar (lambda (x)
                                             (/ (float (string-to-number (substring hex (car x) (cadr x)) 16)) 256))
                                           '((1 3) (3 5) (5 7))))))
      (defun make-color-lighter (hex factor)
        "Make hex color lighter, return string"
        (let ((hsl (hex-to-hsl hex)))
          (eval `(color-rgb-to-hex
                  ,@(color-hsl-to-rgb (car hsl) (min (* (cadr hsl) factor) 1) (min (* (caddr hsl) factor) 1))
                  2))))

      (let* ((eshell-color1 "#268bd2")
             (eshell-color1-lighter (make-color-lighter eshell-color1 1.5))
             (eshell-color2 "#859900")
             (eshell-color2-lighter (make-color-lighter eshell-color2 1.5))
             (eshell-color3 "#2aa198")
             (eshell-color3-lighter (make-color-lighter eshell-color3 1.5))
             (eshell-color4 "#7959AE")
             (eshell-color4-lighter (make-color-lighter eshell-color4 1.5)))

        (setq eshell-prompt-function-light
              #'(lambda nil
                  (concat
                   (propertize "╭─"
                               'face `(:background (face-background 'default) :weight bold))
                   (propertize (user-login-name)
                               'face `(:foreground ,eshell-color1 :weight bold))
                   (propertize " at "
                               'face `(:background (face-background 'default)))
                   (propertize (system-name)
                               'face `(:foreground  ,eshell-color1 :weight bold))
                   (propertize " in "
                               'face `(:background (face-background 'default)))
                   (propertize (abbreviate-file-name (eshell/pwd))
                               'face `(:foreground ,eshell-color2 :weight bold :slant italic))
                   (if (and (boundp 'url-proxy-services)
                            (assoc "http" url-proxy-services))
                       (concat
                        (propertize " via "
                                    'face `(:background (face-background 'default)))
                        (propertize (cdr (assoc "http" url-proxy-services))
                                    'face `(:foreground ,eshell-color3 :weight bold))))
                   (propertize "\n"
                               'face `(:background (face-background 'default)))
                   (propertize "╰─["
                               'face `(:background (face-background 'default) :weight bold))
                   (propertize (if (= (user-uid) 0) "# " "λ")
                               'face `(:slant default :weight bold :foreground ,eshell-color4))
                   (propertize "]"
                               'face `(:background (face-background 'default) :weight bold))
                   (propertize " "
                               'face `(:background (face-background 'default))))))
        (setq eshell-prompt-function-dark
              #'(lambda nil
                  (concat
                   (propertize "╭─"
                               'face `(:background (face-background 'default) :weight bold))
                   (propertize (user-login-name)
                               'face `(:foreground ,eshell-color1-lighter :weight bold))
                   (propertize " at "
                               'face `(:background (face-background 'default)))
                   (propertize (system-name)
                               'face `(:foreground  ,eshell-color1-lighter :weight bold))
                   (propertize " in "
                               'face `(:background (face-background 'default)))
                   (propertize (abbreviate-file-name (eshell/pwd))
                               'face `(:foreground ,eshell-color2-lighter :weight bold :slant italic))
                   (if (and (boundp 'url-proxy-services)
                            (assoc "http" url-proxy-services))
                       (concat
                        (propertize " via "
                                    'face `(:background (face-background 'default)))
                        (propertize (cdr (assoc "http" url-proxy-services))
                                    'face `(:foreground ,eshell-color3-lighter :weight bold))))
                   (propertize "\n"
                               'face `(:background (face-background 'default)))
                   (propertize "╰─["
                               'face `(:background (face-background 'default) :weight bold))
                   (propertize (if (= (user-uid) 0) "# " "λ")
                               'face `(:slant default :weight bold :foreground ,eshell-color4-lighter))
                   (propertize "]"
                               'face `(:background (face-background 'default) :weight bold))
                   (propertize " "
                               'face `(:background (face-background 'default)))))))

      (setq eshell-prompt-regexp "^╰─\\\[[#λ]\\\] ")
      (if (bound-and-true-p init/system-dark-modep)
          (setq eshell-prompt-function
                eshell-prompt-function-dark)
        (setq eshell-prompt-function
              eshell-prompt-function-light))
    #+END_SRC
    This is just for ~shell~ command
    #+BEGIN_SRC emacs-lisp
      (setq comint-prompt-read-only t)
    #+END_SRC
*** Syntax highlight
    #+BEGIN_SRC emacs-lisp
      (init/ensure-package-lazy 'eshell-syntax-highlighting)
      (with-eval-after-load 'eshell
        (require 'eshell-syntax-highlighting)
        (set-face-attribute 'eshell-syntax-highlighting-alias-face
                            nil :weight 'bold)
        (set-face-attribute 'eshell-syntax-highlighting-shell-command-face
                            nil :weight 'bold)
        (unless (bound-and-true-p init/system-dark-modep)
          (progn (set-face-foreground 'eshell-syntax-highlighting-alias-face "#2E67D3")
                 (set-face-foreground 'eshell-syntax-highlighting-shell-command-face "#2E67D3")))
        (add-hook 'eshell-mode-hook 'eshell-syntax-highlighting-mode))
    #+END_SRC
*** FZF fuzzy search
    #+BEGIN_SRC emacs-lisp
      (setq eshell-history-size 1024)
      (defun init/ivy-eshell-history ()
        (interactive)
        (require 'em-hist)
        (let* ((start-pos (save-excursion (eshell-bol) (point)))
               (end-pos (point))
               (input (buffer-substring-no-properties start-pos end-pos))
               (command (ivy-read "Command: "
                                  (delete-dups
                                   (when (> (ring-size eshell-history-ring) 0)
                                     (ring-elements eshell-history-ring)))
                                  :initial-input input)))
          (setf (buffer-substring start-pos end-pos) command)
          (end-of-line)))
    #+END_SRC
*** z-jump
    #+BEGIN_SRC emacs-lisp
      (init/ensure-package-lazy 'eshell-z)
      (with-eval-after-load 'eshell
        (require 'eshell-z))
      ;; (add-hook 'eshell-mode-hook
      ;;           #'(lambda ()
      ;;               (require 'eshell-z)))
    #+END_SRC
*** Colorful ~cat~
    #+BEGIN_SRC emacs-lisp
      (with-eval-after-load 'em-unix
        (defun eshell/cat (&rest args)
          "Like cat(1) but with syntax highlighting."
          (unless args (error "Usage: cat FILE ..."))
          (dolist (filename (eshell-flatten-list args))
            (let ((existing-buffer (get-file-buffer filename))
                  (buffer (find-file-noselect filename)))
              (eshell-print
               (with-current-buffer buffer
                 (if (fboundp 'font-lock-ensure)
                     (font-lock-ensure)
                   (with-no-warnings
                     (font-lock-fontify-buffer)))
                 (buffer-string)))
              (unless existing-buffer
                (kill-buffer buffer))
              nil))))
    #+END_SRC
*** image cat
    #+BEGIN_SRC emacs-lisp
      (defun eshell/imgcat (&rest args)
        "Display image files."
        (unless args (error "Usage: imgcat FILE ..."))
        (dolist (img (eshell-flatten-list args))
          (eshell/printnl
           (propertize " " 'display (create-image img)))))
    #+END_SRC
*** Keybindings
    #+BEGIN_SRC emacs-lisp
      (add-hook 'eshell-mode-hook
                #'(lambda ()
                    (local-set-key (kbd "C-r") #'init/ivy-eshell-history)))
    #+END_SRC
*** Alias
    #+BEGIN_SRC emacs-lisp
      (defun eshell/emacs (file)
        (find-file file))
    #+END_SRC
*** Act
    #+BEGIN_SRC emacs-lisp
      (defun act/eshell ()
        (interactive)
        (let ((buf (eshell 17)))
          (with-current-buffer buf
            (rename-buffer (concat "esh:" (format "%d" (act/eshell-new-index)))))
          (switch-to-buffer buf)))
      (defun act/eshell-new-index ()
        (let* ((index-list (act/eshell-get-index-list))
               (new-buf-index 0)
               (index-arr (make-vector 100 0)))
          (dolist (i index-list)
            (aset index-arr i 1))
          (while (= (aref index-arr new-buf-index) 1)
            (setq new-buf-index (+ new-buf-index 1)))
          new-buf-index))
      (defun act/eshell-get-index-list ()
        (mapcar #'string-to-number
                (mapcar (apply-partially #'replace-regexp-in-string
                                         "esh:"
                                         "")
                        (seq-filter (apply-partially #'string-match-p
                                                     "esh:[0-9]+")
                                    (mapcar #'buffer-name
                                            (buffer-list))))))
    #+END_SRC
*** Issues
    #+BEGIN_SRC emacs-lisp
      (with-eval-after-load 'em-term
        (push "ghci" eshell-visual-commands)
        (push "ssh" eshell-visual-commands)
        (push "htop" eshell-visual-commands)
        (add-hook 'eshell-mode-hook (lambda ()
                                      (setq-local corfu-auto nil))))
    #+END_SRC
** Shell
   #+begin_src emacs-lisp
     (add-hook 'shell-mode-hook (lambda ()
                                  (setq-local corfu-auto nil)
                                  (compilation-shell-minor-mode +1)))
   #+end_src
** Symbol overlay
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package 'symbol-overlay)
     (global-set-key (kbd "M-i") 'symbol-overlay-put)
     (global-set-key (kbd "M-n") 'symbol-overlay-switch-forward)
     (global-set-key (kbd "M-p") 'symbol-overlay-switch-backward)
     (global-set-key (kbd "M-k") 'symbol-overlay-remove-all)
     (add-hook 'prog-mode-hook 'symbol-overlay-mode)
   #+END_SRC
** pdf-tools
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package 'pdf-tools)
     (pdf-loader-install)
     (setq pdf-view-use-scaling t)
   #+END_SRC
** lua-mode
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package 'lua-mode)
   #+END_SRC
** scala-mode
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package 'scala-mode)
   #+END_SRC
** ebib
   #+BEGIN_SRC emacs-lisp :tangle (if (and (boundp 'init/ebib-file-search-dirs) (boundp 'init/ebib-preload-bib-files)) "yes" "no")
     (init/ensure-package-lazy 'ebib)
     (setq ebib-file-search-dirs init/ebib-file-search-dirs)
     (setq ebib-preload-bib-files init/ebib-preload-bib-files)
     (setq ebib-index-columns '(("Entry Key" 20 t)
                                ("Title" 60 t)
                                ("Author/Editor" 40 t)
                                ("Year" 6 t)))
     (setq ebib-index-column-separator "  ")
     (with-eval-after-load 'ebib
       (setq ebib-file-associations nil)
       ;; (add-to-list 'ebib-file-associations '("pdf" . "open"))
       (global-set-key (kbd "C-c e i") 'ebib-insert-citation))
   #+END_SRC
** Org Roam
   #+BEGIN_SRC emacs-lisp :tangle (if (boundp 'init/org-roam-directory) "yes" "no")
     (init/ensure-package-lazy 'org-roam)
     (setq org-roam-directory init/org-roam-directory)
     (defun org-roam-node-find (&optional args)
       "Lazy load wrapper for org-roam"
       (interactive)
       (require 'org-roam)
       (org-roam-setup)
       (org-roam-node-find))
     (defun org-roam-node-insert (&optional args)
       "Lazy load wrapper for org-roam"
       (interactive)
       (require 'org-roam)
       (org-roam-setup)
       (org-roam-node-insert))
     (defun org-roam-node-list (&optional args)
       "Lazy load wrapper for org-roam"
       (interactive)
       (require 'org-roam)
       (org-roam-setup)
       (org-roam-node-list))
     (global-set-key (kbd "C-c n f") #'org-roam-node-find)
     (global-set-key (kbd "C-c n i") #'org-roam-node-insert)
     (global-set-key (kbd "C-c n l") #'org-roam-buffer-list)
   #+END_SRC
*** Advice sort-tab
    #+BEGIN_SRC emacs-lisp
      (advice-add 'sort-tab-get-tab-name
                  :around #'(lambda (origin buf current-buffer)
                              (let* ((name (buffer-name buf))
                                     (short-name (and name
                                                      (replace-regexp-in-string "20[0-9][0-9][01][0-9][0-3][0-9]+-"
                                                                                "" name))))
                                (if (eq (length name) (length short-name))
                                    (apply origin `(,buf ,current-buffer))
                                  (let ((short-name-formatted (concat "roam:"
                                                                      (string-remove-suffix ".org" short-name))))
                                    (propertize
                                     (format " %s "
                                             (let ((ellipsis "..."))
                                               (if (> (length short-name-formatted) sort-tab-name-max-length)
                                                   (format "%s%s"
                                                           (substring short-name-formatted
                                                                      0
                                                                      (- sort-tab-name-max-length (length ellipsis)))
                                                           ellipsis)
                                                 short-name-formatted)))
                                     'face
                                     (if (eq buf current-buffer)
                                         'sort-tab-current-tab-face
                                       'sort-tab-other-tab-face)))))))
    #+END_SRC
** Org Drill
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package-lazy 'org-drill)
     (defun org-find-drill-file ()
       (interactive)
       (find-file init/org-drill-file))
   #+END_SRC
** English Helper
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path
                  (concat user-emacs-directory "site-packages/company-english-helper"))
     (defvaralias 'company-candidates 'corfu--candidates)
     (defalias 'company-mode 'corfu-mode) ;; should be deleted
     (defvaralias 'company-mode 'corfu-mode) ;; should be deleted
     (setq company-backends '())
     (setq completion-at-point-functions-backup completion-at-point-functions)
     (provide 'company)

     (defun set-completion-functions ()
       (setq completion-at-point-functions
             (cl-concatenate 'list (mapcar #'cape-company-to-capf company-backends) completion-at-point-functions-backup)))

     (defun company-grab-symbol ()
       "If point is at the end of a symbol, return it.
         Otherwise, if point is not inside a symbol, return an empty string."
       (if (looking-at "\\_>")
           (buffer-substring (point) (save-excursion (skip-syntax-backward "w_")
                                                     (point)))
         (unless (and (char-after) (memq (char-syntax (char-after)) '(?w ?_)))
           "")))
     (advice-add 'toggle-company-english-helper :after #'set-completion-functions)
     (defun toggle-company-english-helper (&optional args)
       "Lazy load wrapper for english helper"
       (interactive)
       (set-completion-functions)
       (require 'company-english-helper)
       (toggle-company-english-helper))
   #+END_SRC
** Ripgrep
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package-lazy 'rg)
     (defun rg (&optional args)
       "Lazy load wrapper for rg"
       (interactive)
       (require 'rg)
       (rg))
   #+END_SRC
** IBuffer
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package-lazy 'all-the-icons-ibuffer)
     (init/ensure-package-lazy 'ibuffer-projectile)
     (global-set-key (kbd "C-x C-b") #'ibuffer)
     (add-hook 'ibuffer-hook
               (lambda ()
                 (all-the-icons-ibuffer-mode)
                 (ibuffer-projectile-set-filter-groups)
                 (unless (eq ibuffer-sorting-mode 'alphabetic)
                   (ibuffer-do-sort-by-alphabetic))))
     (with-eval-after-load 'ibuffer
       (require 'all-the-icons-ibuffer)
       (require 'ibuffer-projectile))
   #+END_SRC
** Dired
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package-lazy 'all-the-icons-dired)
     (with-eval-after-load 'dired
       (require 'dired-x)
       (require 'all-the-icons-dired))
     (when (string= system-type "darwin")
       (setq dired-use-ls-dired nil))
     (setq dired-omit-files "^\\\.")
     (add-hook 'dired-mode-hook #'all-the-icons-dired-mode)
     (add-hook 'dired-mode-hook #'dired-omit-mode)
     (define-key dired-mode-map (kbd "C-c t") #'dired-omit-mode)
     (define-key dired-mode-map [remap dired-find-file] #'dired-find-alternate-file)
   #+END_SRC
** Word Count
   #+BEGIN_SRC emacs-lisp
     (defvar words-count-rule-chinese "\\cc"
       "A regexp string to match Chinese characters.")

     (defvar words-count-rule-nonespace "[^[:space:]]"
       "A regexp string to match none pace characters.")

     (defvar words-count-rule-ansci "[A-Za-z0-9][A-Za-z0-9[:punct:]]*"
       "A regexp string to match none pace characters.")

     (defvar words-count-regexp-list
       (list words-count-rule-chinese
             words-count-rule-nonespace
             words-count-rule-ansci)
       "A list for the regexp used in `advance-words-count'.")

     (defvar words-count-message-func 'message--words-count
       "The function used to format message in `advance-words-count'.")

     (defun special--words-count (start end regexp)
       "Count the word from START to END with REGEXP."
       (let ((count 0))
         (save-excursion
           (save-restriction
             (goto-char start)
             (while (and (< (point) end) (re-search-forward regexp end t))
               (setq count (1+ count)))))
         count))
     (require 'pos-tip)
     (defun message--words-count (list start end)
       "Display the word count message.
     Using the LIST passed form `advance-words-count'. START & END are
     required to call extra functions, see `count-lines' &
     `count-words'. When ARG is specified, display a verbose buffer."
       (pos-tip-show
        (format
         "
     -----------~*~ Words Count ~*~---------
      Word Count .................... %d
      Characters (without Space) .... %d
      Characters (all) .............. %d
      Number of Lines ............... %d
      ANSCII Chars .................. %d
     %s
     =======================================
     "
         (+ (car list) (car (last list)))
         (cadr list)
         (- end start)
         (count-lines start end)
         (car (last list))
         (concat
          (unless (= 0 (car list))
            (format " Chinese Chars ................. %d\n"
                    (car list)))
          (format " English Words ................. %d\n"
                  (count-words start end))))
        nil nil nil -1))

     ;;;###autoload
     (defun advance-words-count (beg end)
       "Chinese user preferred word count.
     If BEG = END, count the whole buffer. If called initeractively,
     use minibuffer to display the messages. The optional ARG will be
     passed to `message--words-count'.

     See also `special-words-count'."
       (interactive (if (use-region-p)
                        (list (region-beginning)
                              (region-end))
                      (list nil nil)))
       (let ((min (or beg (point-min)))
             (max (or end (point-max)))
             list)
         (setq list
               (mapcar
                (lambda (r) (special--words-count min max r))
                words-count-regexp-list))
         (if (called-interactively-p 'any)
             (message--words-count list min max)
           list)))
   #+END_SRC
** Setup hideshow
#+BEGIN_SRC emacs-lisp
  (require 'hideshow)
  (add-hook 'prog-mode-hook 'hs-minor-mode)
  (defun hs-toggle-hiding-or-indent-for-tab-command (&optional arg)
      (interactive "P")
      (let ((oldpos (point)))
        (back-to-indentation)
        (if (hs-looking-at-block-start-p)
            (hs-toggle-hiding)
          (progn
            (goto-char oldpos)
            (indent-for-tab-command arg)))))
  (define-key hs-minor-mode-map (kbd "TAB") #'hs-toggle-hiding-or-indent-for-tab-command)
#+END_SRC
Make the overlay look nicer
#+BEGIN_SRC emacs-lisp
  (defconst hideshow-folded-face '((t (:inherit 'font-lock-comment-face :box t))))
  (defun hideshow-folded-overlay-fn (ov)
      (when (eq 'code (overlay-get ov 'hs))
        (let* ((nlines (count-lines (overlay-start ov) (overlay-end ov)))
               (info (format " ... #%d " nlines)))
          (overlay-put ov 'display (propertize info 'face hideshow-folded-face)))))
  (setq hs-set-up-overlay 'hideshow-folded-overlay-fn)
#+END_SRC
** Writeroom mode
   This package comes with autoload
   #+BEGIN_SRC emacs-lisp
     (init/ensure-package-lazy 'writeroom-mode)
     (setq writeroom-width 120)
     (with-eval-after-load 'writeroom-mode
       (setq writeroom-global-effects
             (delq 'writeroom-set-menu-bar-lines
                   (delq 'writeroom-set-fullscreen writeroom-global-effects))))
     (advice-add #'writeroom--set-global-effects :after
                 #'sort-tab-refresh)
   #+END_SRC
** Tramp
   #+begin_src emacs-lisp
     (setq-default tramp-verbose 1)
   #+end_src
** Enable disabled feature
   #+begin_src emacs-lisp
     (put 'dired-find-alternate-file 'disabled nil)
     (put 'narrow-to-region 'disabled nil)
   #+end_src
