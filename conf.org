#+TITLE: Configuration for Emacs
#+PROPERTY: header-args :results silent :tangle conf.el
#+BEGIN_SRC emacs-lisp
  ;;; conf.el --- Configuration generated by conf.org -*- lexical-binding: t; -*-
#+END_SRC

* Infrastructure
** Initialize packages

#+BEGIN_SRC emacs-lisp
  (package-initialize)
#+END_SRC


** Macros

#+begin_src emacs-lisp
  (defmacro add-hook-lambda (hook arg &rest rest-args)
    `(if (listp (quote ,hook))
         (dolist (hook (quote ,hook))
           (add-hook hook
                     (lambda ()
                       ,arg
                       ,@rest-args)))
       (add-hook (quote ,hook) (lambda ()
                                 ,arg
                                 ,@rest-args))))

  (defmacro switch-to-tab-before (action tab-name)
    `(advice-add (quote ,action) :before
                 (lambda (&rest _)
                   (if (member ,tab-name (mapcar (lambda (tab)
                                                   (alist-get 'name tab))
                                                 (tab-bar-tabs)))
                       (tab-bar-switch-to-tab ,tab-name)
                     (tab-bar-new-tab)
                     (tab-bar-rename-tab ,tab-name)))))

  (defmacro execute-command-in (action directory)
    `(advice-add (quote ,action) :around
                 (lambda (origin-fun &rest args)
                   (let ((default-directory ,directory))
                     (apply origin-fun args)))))
#+end_src
** User defined actions

User defined actions begin with =init=.

*** Auto install packages

#+BEGIN_SRC emacs-lisp
  (defun init/ensure-package (pkg)
    "ensure that package is installed, require it"
    (if (ignore-errors (require pkg))
        t
      (progn
        (unless (package-installed-p pkg)
          (package-refresh-contents)
          (package-install pkg))
        (unless (ignore-errors (require pkg))
          nil
          ;; (warn (format "(init/ensure-package) feature %s doesn't exist" pkg))
          )
        nil)))
  (defun init/ensure-package-lazy (pkg)
    "ensure package is installed, donot require"
    (unless (package-installed-p pkg)
      (package-refresh-contents)
      (package-install pkg)))
#+END_SRC

*** Toggle sudo in a buffer

#+BEGIN_SRC emacs-lisp
  (require 'tramp)
  (defun init/toggle-sudo-in-current-buffer ()
    (interactive)
    (when (buffer-file-name)
      (let* ((sudo-buffer (current-buffer))
             (sudo-buffer-name (buffer-file-name sudo-buffer)))
        (if (memq sudo-buffer (tramp-list-remote-buffers))
            (find-file (concat "/" (file-remote-p sudo-buffer-name 'method) ":"
                               (file-remote-p sudo-buffer-name 'user)
                               "@" (file-remote-p sudo-buffer-name 'host) "|"
                               "sudo::"
                               (file-remote-p sudo-buffer-name 'localname)))
          (find-file (concat "/sudo:root@localhost:/" (buffer-file-name sudo-buffer))))
        (kill-buffer sudo-buffer))))
#+END_SRC

*** Find ~init.el~

#+BEGIN_SRC emacs-lisp
  (defun init/find-init ()
    "Find default `init.el' file"
    (interactive) (find-file "~/.config/emacs/init.el"))
#+END_SRC

*** Find ~conf.org~

#+BEGIN_SRC emacs-lisp
  (defun init/find-conf ()
    "Find default `conf.org' file"
    (interactive) (find-file "~/.config/emacs/conf.org"))
  (switch-to-tab-before init/find-conf "emacs")
#+END_SRC

*** Open file in external applications

#+BEGIN_SRC emacs-lisp
  (defun init/open-file-in-external-application (&optional args)
    "Open current buffer in external applications"
    (interactive)
    (ivy-read "Type"
              '("File" "Dir")
              :action #'open-file-in-external-application-action))
  (pcase system-type
    ('darwin
     (defun open-file-in-external-application-action (arg)
      (if (buffer-file-name)
          (pcase arg
            ("Dir" (call-process "open" nil 0 nil default-directory))
            ("File" (call-process "open" nil 0 nil (buffer-file-name))))
        (message "The buffer is not a file"))))
    ('gnu/linux
     (defun open-file-in-external-application-action (arg)
      (if (buffer-file-name)
          (pcase arg
            ("Dir" (call-process "xdg-open" nil 0 nil default-directory))
            ("File" (call-process "xdg-open" nil 0 nil (buffer-file-name))))
        (message "The buffer is not a file")))))
#+END_SRC

*** Toggle proxy

The proxy is turned on iff. =init/local-proxies= is defined in =local-variables.el=.

#+BEGIN_SRC emacs-lisp :tangle (if (boundp 'init/local-proxies) "yes" "no")
  (defun init/toggle-url-proxy ()
    "Toggle proxy for the url.el library."
    (interactive)
    (cond
     (url-proxy-services
      (message "Turn off URL proxy")
      (setq url-proxy-services nil))
     (t
      (message "Turn on URL proxy")
      (setq url-proxy-services init/local-proxies))))
#+END_SRC

*** Highlight actions

These actions are done with package =pulse.el=.

#+begin_src emacs-lisp
  (require 'pulse)
#+end_src
**** Highlight =yank= actions

#+begin_src emacs-lisp
  (defun yank-pulse-advice (orig-fn &rest args)
    ;; Define the variables first
    (let (begin end)
      ;; Initialize `begin` to the current point before pasting
      (setq begin (point))
      ;; Forward to the decorated function (i.e. `yank`)
      (apply orig-fn args)
      ;; Initialize `end` to the current point after pasting
      (setq end (point))
      ;; Pulse to highlight!
      (pulse-momentary-highlight-region begin end)))
  (advice-add 'yank :around #'yank-pulse-advice)
#+end_src


**** Highlight after window switching

#+begin_src emacs-lisp
  (dolist (cmd
           '(other-window
             centaur-tabs-forward-tab
             centaur-tabs-backward-tab
             recenter-top-bottom
             org-goto
             push-button
             symbol-overlay-jump-call
             ace-window))
    (advice-add cmd :after #'(lambda (&rest _)
                               (pulse-momentary-highlight-one-line))))

#+end_src
** Default behaviors

*** Use 4 spaces instead of tab

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

*** Save cursor position in file

#+BEGIN_SRC emacs-lisp
  (save-place-mode)
#+END_SRC

*** Set cursor style and enable blinking

#+begin_src emacs-lisp
  (add-hook-lambda org-mode-hook (setq cursor-type '(bar . 3)))
  (blink-cursor-mode -1)
#+end_src

*** Go to first char instead of line head

#+BEGIN_SRC emacs-lisp
  (defun smart-beginning-of-line ()
    "Move point to first non-whitespace character or beginning-of-line.
  Move point to the first non-whitespace character on this line.
  If point is already at that position, move point to the beginning of line."
    (interactive)
    (let ((oldpos (point)))
      (back-to-indentation)
      (and (= oldpos (point))
           (beginning-of-line))))
  (global-set-key [home] 'smart-beginning-of-line)
  (global-set-key "\C-a" 'smart-beginning-of-line)
#+END_SRC

*** Enable CUA selection mode (delete on selection)

#+BEGIN_SRC emacs-lisp
  (setq cua-delete-selection t)
  (cua-selection-mode t)
  (set-face-attribute 'cua-rectangle nil :background (face-background 'region))
#+END_SRC

*** Set frame title

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format '(:eval
                             (buffer-name)))
#+END_SRC

*** Disable visible warning and cursor

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
  (setq visible-bell nil
        visible-cursor nil
        ring-bell-function 'ignore)
#+END_SRC

*** Use y/n instead of yes/no

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Follow symbolic link by default

#+begin_src emacs-lisp
  (setq vc-follow-symlinks t)
#+end_src

*** Disable annoying ~$FILENAME~~

#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
#+END_SRC

*** Setup initial buffer

#+BEGIN_SRC emacs-lisp
  (setq-default initial-scratch-message "")
  (add-hook-lambda emacs-startup-hook
                   (switch-to-buffer "*scratch*")
                   (goto-char (point-min))
                   (insert (concat ";; start up cost: "
                                   (emacs-init-time)
                                   "\n\n")))
#+END_SRC

*** Define path

=init/define-path= is the function used to setup environment variables
of Emacs. For example (this function is not tangled)

#+begin_src emacs-lisp :tangle no
  (error "This part should not be tangled: init/define-path")
  (defun init/define-path ()
    "Example of `init/define-path', this function is not tangled"
    (custom-set-variables
     '(conda-anaconda-home "~/.local/miniconda3"))
    (add-to-list 'exec-path "~/.cargo/bin")
    (setenv "RUSTUP_DIST_SERVER" "https://example.com")
    (if init/local-proxies
        (progn
          (setenv "socks5_proxy" "socks5://localhost:1234")
          (setenv "http_proxy" "http://localhost:1234")
          (setenv "https_proxy" (getenv "http_proxy"))
          (setenv "all_proxy" (getenv "http_proxy"))))
    (setenv "PATH" (mapconcat 'identity exec-path ":")))
#+end_src

#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'init/define-path) "yes" "no")
  (init/define-path)
#+END_SRC

*** Disable suspend-frame

#+begin_src emacs-lisp
  (global-unset-key (kbd "C-z"))
#+end_src

*** Auto remove trailing whitespaces

#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src
** Navigation & Searching system
*** Basic packages

#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'ivy)
  ;; (init/ensure-package 'swiper)
  (init/ensure-package 'counsel)
  (init/ensure-package 'ivy-prescient)
#+END_SRC

*** Configure ivy

**** Hook at startup

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'ivy-mode)
#+END_SRC

**** Default variables

#+BEGIN_SRC emacs-lisp
  (setq-default ivy-use-virtual-buffers t
                ivy-virtual-abbreviate 'fullpath
                ivy-count-format "%-4d "
                ivy-magic-tilde nil
                ivy-dynamic-exhibit-delay-ms 150
                ivy-use-selectable-prompt t
                ivy-switch-buffer-faces-alist nil)
#+END_SRC

**** Issues

Enable ~escape~ as quit in ivy
#+BEGIN_SRC emacs-lisp
  (define-key ivy-minibuffer-map [escape] 'minibuffer-keyboard-quit)
#+END_SRC

*** Config isearch

#+BEGIN_SRC emacs-lisp
  (define-key isearch-mode-map
    [remap isearch-delete-char]
    #'isearch-del-char)
  (setq isearch-lazy-count t)
  (setq lazy-count-prefix-format "%s/%s ")
  (setq lazy-highlight-cleanup t)
#+END_SRC

*** Configure counsel

**** Hook at startup

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'counsel-mode)
#+END_SRC

**** Default variables

#+BEGIN_SRC emacs-lisp
  (setq-default counsel-mode-override-describe-bindings t
                ivy-initial-inputs-alist '((Man-completion-table . "^")
                                           (woman . "^")))
#+END_SRC

**** Keybinding

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-x") 'counsel-M-x)
#+END_SRC

*** Configure ivy-prescient

~prescient~ is required for history look-up

#+BEGIN_SRC emacs-lisp
  (ivy-prescient-mode)
  (prescient-persist-mode +1)
#+END_SRC

** Project manager

The default project manager is built-in =project.el=.
The default project finder is =find=.
We replece it with =fd= to speed up the searching.

#+begin_src emacs-lisp
  (defun my/project-files-in-directory (dir)
    "Use `fd' to list files in DIR."
    (let* ((default-directory dir)
           (localdir (file-local-name (expand-file-name dir)))
           (command (format "fd -H -t f -0 . %s" localdir)))
      (project--remote-file-names
       (sort (split-string (shell-command-to-string command) "\0" t)
             #'string<))))

  (cl-defmethod project-files ((project (head local)) &optional dirs)
    "Override `project-files' to use `fd' in local projects."
    (mapcan #'my/project-files-in-directory
            (or dirs (list (project-root project)))))

  ;; (define-key ivy-mode-map
  ;;   [remap switch-to-buffer]
  ;;   (lambda ()
  ;;     (interactive)
  ;;     (if (or current-prefix-arg
  ;;             (not (project-current nil)))
  ;;         (call-interactively 'ivy-switch-buffer)
  ;;       (call-interactively 'project-switch-to-buffer))))

  ;; (define-key counsel-mode-map
  ;;   [remap find-file]
  ;;   (lambda ()
  ;;     (interactive)
  ;;     (if (or current-prefix-arg
  ;;             (not (project-current nil)))
  ;;         (call-interactively 'counsel-find-file)
  ;;       (call-interactively 'project-find-file))))
#+end_src

The project keymap is built in Emacs and starts with =C-x p=.
The most useful functions among them are listed here.

| Key     | function                    |
| C-x p f | find-file in project        |
| C-x p b | switch-to-buffer in project |
| C-x p p | switch project              |
| C-x p d | dired in project            |


** Helping System

*** Basic packages

#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'which-key)
  (init/ensure-package 'helpful)
#+END_SRC

*** Configurations

#+BEGIN_SRC emacs-lisp
  (which-key-mode 1)
  (setq counsel-describe-function-function #'helpful-callable
        counsel-describe-variable-function #'helpful-variable)
  (global-set-key (kbd "C-h k") #'helpful-key)
  (global-set-key (kbd "C-h d") #'helpful-at-point)
  (define-key helpful-mode-map (kbd "n") #'next-line)
  (define-key helpful-mode-map (kbd "p") #'previous-line)
  (define-key help-mode-map (kbd "n") #'next-line)
  (define-key help-mode-map (kbd "p") #'previous-line)
#+END_SRC

** Auto Save

#+begin_src emacs-lisp
  (add-to-list 'load-path
               (concat user-emacs-directory "site-packages/auto-save"))
  (require 'auto-save)
  (auto-save-enable)
  (setq auto-save-silent t)
#+end_src

** Window management

*** Buffer management

#+begin_src emacs-lisp
  (init/ensure-package 'buffer-move)
  (global-set-key (kbd "<C-S-up>")     'buf-move-up)
  (global-set-key (kbd "<C-S-down>")   'buf-move-down)
  (global-set-key (kbd "<C-S-left>")   'buf-move-left)
  (global-set-key (kbd "<C-S-right>")  'buf-move-right)

  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "<C-S-up>")     'buf-move-up)
    (define-key org-mode-map (kbd "<C-S-down>")   'buf-move-down)
    (define-key org-mode-map (kbd "<C-S-left>")   'buf-move-left)
    (define-key org-mode-map (kbd "<C-S-right>")  'buf-move-right))
#+end_src

*** Popup control

#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'popper)
  (init/ensure-package 'popper-echo)
  (setq popper-reference-buffers
        `("\\*Messages\\*"
          "Output\\*$"
          "\\*Async Shell Command\\*"
          help-mode
          helpful-mode
          compilation-mode
          Man-mode
          package-menu-mode
          pdf-outline-buffer-mode
          outline-mode))
  (global-set-key (kbd "<C-tab>") 'popper-toggle-latest)
  (define-key popper-mode-map (kbd "<C-tab>") 'popper-cycle)
  (global-set-key (kbd "<C-escape>") 'popper-kill-latest-popup)
  (popper-mode +1)
  (popper-echo-mode +1)
#+END_SRC

*** Window switching

#+begin_src emacs-lisp
  (defun transient-switch-window ()
    "Transient switch window by window's number"
    (interactive)
    (if (length> (window-list) 1)
        (let ((echo-keystrokes nil))
          (call-interactively 'other-window)
          (message "transient other window")
          (set-transient-map
           (let ((map (make-sparse-keymap)))
             (define-key map "o" (lambda () (interactive)
                                   (call-interactively 'other-window)))
             map)
           t))
      (message "No other window to select")))
  (global-set-key [remap other-window] 'transient-switch-window)
#+end_src

*** Resize
#+begin_src emacs-lisp
  (defun transient-enlarge-window-horizontally ()
    "Transient version of `enlarge-window-horizontally"
    (interactive)
    (let ((echo-keystrokes nil))
      (enlarge-window-horizontally 1)
      (message "Resize: [{] Shrink-h, [}] Enlarge-h, [&] Shrink-v, [^] Enlarge-v")
      (set-transient-map
       (let ((map (make-sparse-keymap)))
         (define-key map [?{] #'shrink-window-horizontally)
         (define-key map [?}] #'enlarge-window-horizontally)
         (define-key map [?&] #'shrink-window)
         (define-key map [?^] #'enlarge-window)
         map)
       t)))

  (defun transient-shrink-window-horizontally ()
    "Transient version of `shrink-window-horizontally"
    (interactive)
    (let ((echo-keystrokes nil))
      (shrink-window-horizontally 1)
      (message "Resize: [{] Shrink-h, [}] Enlarge-h, [&] Shrink-v, [^] Enlarge-v")
      (set-transient-map
       (let ((map (make-sparse-keymap)))
         (define-key map [?{] #'shrink-window-horizontally)
         (define-key map [?}] #'enlarge-window-horizontally)
         (define-key map [?&] #'shrink-window)
         (define-key map [?^] #'enlarge-window)
         map)
       t)))

  (defun transient-shrink-window ()
    "Transient version of `shrink-window"
    (interactive)
    (let ((echo-keystrokes nil))
      (shrink-window 1)
      (message "Resize: [{] Shrink-h, [}] Enlarge-h, [&] Shrink-v, [^] Enlarge-v")
      (set-transient-map
       (let ((map (make-sparse-keymap)))
         (define-key map [?{] #'shrink-window-horizontally)
         (define-key map [?}] #'enlarge-window-horizontally)
         (define-key map [?&] #'shrink-window)
         (define-key map [?^] #'enlarge-window)
         map)
       t)))

  (defun transient-enlarge-window ()
    "Transient version of `enlarge-window"
    (interactive)
    (let ((echo-keystrokes nil))
      (enlarge-window 1)
      (message "Resize: [{] Shrink-h, [}] Enlarge-h, [&] Shrink-v, [^] Enlarge-v")
      (set-transient-map
       (let ((map (make-sparse-keymap)))
         (define-key map [?{] #'shrink-window-horizontally)
         (define-key map [?}] #'enlarge-window-horizontally)
         (define-key map [?&] #'shrink-window)
         (define-key map [?^] #'enlarge-window)
         map)
       t)))

  (global-set-key [remap enlarge-window-horizontally]
                  'transient-enlarge-window-horizontally)
  (global-set-key [remap shrink-window-horizontally]
                  'transient-shrink-window-horizontally)
  (global-set-key [remap enlarge-window]
                  'transient-enlarge-window)
  (global-set-key (kbd "C-x &")
                  'transient-shrink-window)
#+end_src
* Look and feel

*This part should not be changed frequently.
Spend time on important things.*

** Fonts
 Set default font, the font size configuration is moved to ~local-variables.el~
#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (dolist (font '("Symbol" "Apple Color Emoji" "Segoe UI Symbol" "Symbola"))
      (set-fontset-font t 'unicode font nil 'prepend))
    (when (boundp 'cn-font)
     (dolist (charset '(kana han cjk-misc bopomofo))
       (set-fontset-font t charset
                         (font-spec :family cn-font))))
    (when (boundp 'frame-font)
     (set-frame-font frame-font nil t)))
#+END_SRC
*** prog-mode font

Use separate font for ~prog-mode~
#+BEGIN_SRC emacs-lisp
  (when (boundp 'cc-font)
   (defface cc-font
     `((t :family ,cc-font))
     "program fonts"
     :group 'basic-faces))
  (set-face-attribute 'fixed-pitch nil
                      :family (face-attribute 'cc-font :family))
#+END_SRC

** Ligature

*** MacOS

#+BEGIN_SRC emacs-lisp :tangle (if (eq system-type 'darwin) "yes" "no")
  (mac-auto-operator-composition-mode +1)
#+END_SRC

*** Linux

#+begin_src emacs-lisp :tangle (if (eq system-type 'gnu/linux) "yes" "no")
  (add-to-list 'load-path
               (concat user-emacs-directory "site-packages/ligature"))
  (require 'ligature)
  (ligature-set-ligatures 't '("www"))
  ;; Enable traditional ligature support in eww-mode, if the
  ;; `variable-pitch' face supports it
  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
  ;; Enable ligature in other documentation mode
  (dolist (mode '(org-mode markdown-mode))
    (ligature-set-ligatures mode '("ff" "fi" "ffi")))
  ;; Enable all ligatures in programming modes
  (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--"
                                       "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>"
                                       "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-"
                                       ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>"
                                       "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<"
                                       "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "///" "_|_"
                                       "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||"
                                       "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<"
                                       "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->"
                                       "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+"
                                       "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".="
                                       ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/="
                                       "/>" "//" "__" "~~" "(*" "*)"
                                       "\\\\" "://"))
  (global-ligature-mode t)
#+end_src

*** pagebreak
#+begin_src emacs-lisp
  (init/ensure-package 'page-break-lines)
  (add-hook-lambda (prog-mode-hook conf-mode-hook yaml-mode-hook)
                        (page-break-lines-mode))
#+end_src
** Smooth scrolling
#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 0)
  (setq scroll-step 1)
  (setq scroll-conservatively 101)
  (setq scroll-up-aggressively 0.01)
  (setq scroll-down-aggressively 0.01)
  (setq auto-window-vscroll nil)
  (setq fast-but-imprecise-scrolling nil)
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
  (setq mouse-wheel-progressive-speed nil)
  ;; Horizontal Scroll
  (setq hscroll-step 1)
  (setq hscroll-margin 0)
#+END_SRC
** Theme
*** Issues
We need to advice the theme changer so that theme can be completely
changed in runtime.
#+BEGIN_SRC emacs-lisp
  (defcustom load-theme-before-hook nil
    "Functions to run before load theme."
    :type 'hook)
  (defcustom load-theme-after-hook nil
    "Functions to run after load theme."
    :type 'hook)
  (defun load-theme-hook-wrapper (origin-func theme &rest args)
    "A wrapper of hooks around `load-theme'."
    (mapc #'disable-theme custom-enabled-themes)
    (run-hook-with-args 'load-theme-before-hook theme)
    (apply origin-func theme args)
    (run-hook-with-args 'load-theme-after-hook theme))
  (advice-add 'load-theme :around #'load-theme-hook-wrapper)
#+END_SRC
*** Setup theme
Setup theme.

#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
   (if (and (boundp 'init/theme-dark)
            (bound-and-true-p init/system-dark-modep))
       (load-theme init/theme-dark 1)
     (if (boundp 'init/theme-light)
         (load-theme init/theme-light 1))))
#+END_SRC

*** Add fringe indicators
#+begin_src emacs-lisp
  (add-hook-lambda (prog-mode-hook text-mode-hook telega-chat-mode-hook wl-summary-mode-hook)
                        (setq indicate-buffer-boundaries 'right))
#+end_src

** Icon
Set up all-the-icons
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'all-the-icons)
#+END_SRC
I do not manually install the fonts of ~all-the-icons~. System package manager (~pacman~) maintains the font.
** Tabs
*** tab bar
#+begin_src emacs-lisp
  (global-set-key (kbd "<S-left>")  'tab-bar-switch-to-prev-tab)
  (global-set-key (kbd "<S-right>") 'tab-bar-switch-to-next-tab)
  (with-eval-after-load 'org
        (define-key org-mode-map (kbd "<S-left>") 'tab-bar-switch-to-prev-tab)
        (define-key org-mode-map (kbd "<S-right>") 'tab-bar-switch-to-next-tab))

  (defun vc-branch-name ()
    (when vc-mode
      (propertize
       (replace-regexp-in-string
        "Git[-:]"
        ""
        (substring-no-properties vc-mode))
       'face
       'bold)))

  (defun time ()
    (let* ((now (current-time))
           (time (current-time-string now))
           (load (display-time-update--load))
           (mail (display-time-update--mail))
           (24-hours (substring time 11 13))
           (hour (string-to-number 24-hours))
           (12-hours (int-to-string (1+ (% (+ hour 11) 12))))
           (am-pm (if (>= hour 12) "pm" "am"))
           (minutes (substring time 14 16))
           (seconds (substring time 17 19))
           (time-zone (car (cdr (current-time-zone now))))
           (day (substring time 8 10))
           (year (format-time-string "%Y" now))
           (monthname (substring time 4 7))
           (month
            (cdr
             (assoc
              monthname
              '(("Jan" . "1") ("Feb" . "2") ("Mar" . "3") ("Apr" . "4")
                ("May" . "5") ("Jun" . "6") ("Jul" . "7") ("Aug" . "8")
                ("Sep" . "9") ("Oct" . "10") ("Nov" . "11") ("Dec" . "12")))))
           (dayname (substring time 0 3)))
      (concat dayname " " day " " monthname ", " 12-hours ":" minutes " " am-pm)))

  (defun rpath ()
    (let ((project-current (project-current)))
      (if project-current
          (file-relative-name default-directory
                              (project-root project-current))
        default-directory)))

  (defun tab-bar-right ()
    (let* ((info (rpath))
           (w (string-width info)))
      (concat (propertize " " 'display `((space :align-to (- (+ right right-fringe right-margin) ,w 1))))
              info)))


  (defun tab-bar-switch-project ()
    "Switch to project in a new tab, project name will be used as tab name.
  No tab will created if the command is cancelled."
    (interactive)
    (let (succ)
      (unwind-protect
          (progn
            (tab-bar-new-tab)
            (call-interactively #'project-switch-project)
            (when-let ((proj (project-current)))
              (tab-bar-rename-tab (format "%s" (file-name-nondirectory (directory-file-name (cdr proj)))))
              (setq succ t)))
        (unless succ
          (tab-bar-close-tab)))))
  (global-set-key [remap project-other-tab-command] 'tab-bar-switch-project)
  (defun +tab-bar-tab-format-function (tab i)
    (let ((current-p (eq (car tab) 'current-tab)))
      (concat
       (propertize (concat
                    " "
                    (alist-get 'name tab)
                    " ")
                   'face
                   (funcall tab-bar-tab-face-function tab))
       " ")))

  (setq tab-bar-border nil
        tab-bar-close-button nil
        tab-bar-back-button nil
        tab-bar-new-button nil
        tab-bar-tab-name-format-function '+tab-bar-tab-format-function
        tab-bar-format '(tab-bar-format-tabs tab-bar-right)
        tab-bar-tab-name-truncated-max 10)
  ;; (set-face-attribute 'tab-bar-tab-inactive nil
  ;;                     :background (face-background 'tab-bar)
  ;;                     :box nil)
  (tab-bar-mode)
#+end_src
** Modeline

#+begin_src emacs-lisp
  (init/ensure-package 'minions)
  (minions-mode)
  (when (display-graphic-p)
   (init/ensure-package 'moody)
   (setq x-underline-at-descent-line t)
   (moody-replace-mode-line-buffer-identification)
   (moody-replace-vc-mode)
   (moody-replace-eldoc-minibuffer-message-function))
  (column-number-mode 1)
  (size-indication-mode 1)
#+end_src
** Line number & highlight current line
#+BEGIN_SRC emacs-lisp
  ;; (require 'hl-line)
  (add-hook-lambda (prog-mode-hook conf-mode-hook yaml-mode-hook)
                   (display-line-numbers-mode)
                   ;;(hl-line-mode)
                   )
#+END_SRC

*** Scaling as text-scaling happens
#+begin_src emacs-lisp
  (defun post-text-scale-callback ()
    ;; fix line number text size
    (let ((new-size (floor (* (face-attribute 'default :height)
                              (expt text-scale-mode-step text-scale-mode-amount)))))
      (set-face-attribute 'line-number nil :height new-size)
      (set-face-attribute 'line-number-current-line nil :height new-size)))

  (add-hook 'text-scale-mode-hook 'post-text-scale-callback)
#+end_src
** Extra features
*** Rich ivy
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'ivy-rich)
  (init/ensure-package 'all-the-icons-ivy-rich)
  (ivy-rich-mode 1)
  (all-the-icons-ivy-rich-mode 1)
  (setq ivy-rich-parse-remote-buffer nil)
#+END_SRC
*** Brackets
**** Look
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'rainbow-delimiters)
  (init/ensure-package 'highlight-parentheses)
#+END_SRC
**** Display
#+BEGIN_SRC emacs-lisp
  (add-hook-lambda (prog-mode-hook conf-mode-hook yaml-mode-hook)
                        (show-paren-mode)
                        (highlight-parentheses-mode))
#+END_SRC
**** Smart parens
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'smartparens)
  (add-hook 'after-init-hook 'smartparens-global-mode)
  (sp-pair "(" nil :unless '(sp-point-before-word-p))
  (sp-pair "[" nil :unless '(sp-point-before-word-p))
  (sp-pair "{" nil :unless '(sp-point-before-word-p))
  (sp-pair "\"" nil :unless '(sp-point-before-word-p))
  (sp-pair "\'" nil :unless '(sp-point-before-word-p))
  (sp-pair "`" nil :actions :rem)
#+END_SRC
*** Display HEX/RGB color
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'rainbow-mode)
#+END_SRC
* Languages
** Citre
#+begin_src emacs-lisp
  (init/ensure-package 'citre)
  (require 'citre-config)
  (setq citre-peek-auto-restore-after-jump nil)
  (define-key prog-mode-map (kbd "M-.") #'citre-peek)
  (define-key citre-peek-keymap (kbd "M-.") #'(lambda ()
                                                (interactive)
                                                (citre-peek-jump)))

#+end_src
** Completion system
*** Yasnippet
#+begin_src emacs-lisp
  (init/ensure-package 'yasnippet)
  (yas-reload-all)
  (yas-global-mode)
#+end_src
*** LSP Bridge
#+begin_src emacs-lisp
  (init/ensure-package 'posframe)
  (init/ensure-package 'markdown-mode)
  (add-to-list 'load-path
               (concat user-emacs-directory "site-packages/lsp-bridge"))
  (require 'lsp-bridge)
  ;; (global-lsp-bridge-mode)
  (add-hook 'prog-mode-hook #'lsp-bridge-mode)
  (setq-default lsp-bridge-enable-search-words nil)
  (setq-default acm-enable-search-words nil)
  (setq-default acm-enable-search-file-words nil)
  (unless (display-graphic-p)
    (add-to-list 'load-path (concat user-emacs-directory "site-packages/acm-terminal"))
    (add-to-list 'load-path (concat user-emacs-directory "site-packages/popon"))
    (with-eval-after-load 'acm
      (require 'acm-terminal)))
#+end_src
** Tree-sitter Integration

Tree-sitter is helpful in structual editing and grammar highlighting.
To install tree-sitter.

#+begin_src emacs-lisp
  (init/ensure-package-lazy 'tree-sitter)
  (init/ensure-package-lazy 'tree-sitter-langs)
#+end_src

Enable tree-sitter in =prog-mode=.

#+begin_src emacs-lisp
  (add-hook-lambda (c-mode-common-hook c-mode-hook c++-mode-hook python-mode-hook rust-mode-hook shell-mode-hook scala-mode-hook)
                   (tree-sitter-mode 1)
                   (tree-sitter-hl-mode 1))
#+end_src
** Common Lisp
#+begin_src emacs-lisp
  (let ((lisp-helper (expand-file-name "~/.config/quicklisp/slime-helper.el")))
    (if (file-exists-p lisp-helper)
        (load lisp-helper)))
  (setq inferior-lisp-program "sbcl")
#+end_src
** Python
*** Conda
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'conda)
#+END_SRC


Setup conda

#+BEGIN_SRC emacs-lisp
  (conda-env-initialize-eshell)
  (conda-env-activate 'base)
#+END_SRC
*** Highlight Indentation
#+begin_src emacs-lisp
  (init/ensure-package-lazy 'highlight-indentation)
  (with-eval-after-load 'highlight-indentation
   (set-face-background 'highlight-indentation-face "#e3e3d3")
   (set-face-background 'highlight-indentation-current-column-face "#c3b3b3"))
  (add-hook 'python-mode-hook 'highlight-indentation-mode)
#+end_src
** C/C++
#+begin_src emacs-lisp
  (setq lsp-bridge-c-lsp-server "clangd")
#+end_src
** Rust
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'rust-mode)
  (add-hook-lambda rust-mode-hook
                   (setq-local compile-command "cargo build"))
#+END_SRC
** Haskell
#+begin_src emacs-lisp
  (init/ensure-package-lazy 'haskell-mode)
  (setq haskell-process-type 'stack-ghci)
#+end_src
** Emacs-Lisp
Use =paredit= in =elisp-mode=.  Configure =smartparen= mode.
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'paredit)
  (setq backward-delete-char-untabify-method 'all)
  (add-hook 'scheme-mode-hook 'paredit-mode)
  (add-hook 'scheme-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
  (add-hook 'emacs-lisp-mode 'rainbow-delimiters-mode)
  (dolist (mode '(emacs-lisp-mode elisp-mode))
    (sp-local-pair mode "'" nil :actions nil))
#+END_SRC
** Shell
Install ~fish-mode~ and config keybindings
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'fish-mode)
#+END_SRC
** Matlab
Install ~matlab-mode~
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'matlab-mode)
  (setq-default matlab-verify-on-save-flag nil)
#+END_SRC
** YAML
Install ~yaml-mode~
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'yaml-mode)
#+END_SRC
* Documentation
** Spell Check

#+begin_src emacs-lisp
  (setq ispell-dictionary "en_US"
        ispell-program-name "aspell"
        ;; ispell-personal-dictionary (expand-file-name "hunspell_dict.txt" user-emacs-directory)
        )
#+end_src
** Emacs Rime
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'rime)
  (with-eval-after-load 'rime
    (add-hook 'kill-emacs-hook #'rime-lib-finalize) ;; avoid crash on exit
    (set-face-attribute 'rime-highlight-candidate-face nil :weight 'bold)
    (define-key rime-mode-map [escape] #'rime-inline-ascii)
    (advice-add 'rime-inline-ascii :after
                #'(lambda ()
                    (interactive)
                    (if (rime--ascii-mode-p)
                        (message "%s"
                                 (concat "rime inline ascii "
                                         (propertize "enabled" 'face '(:foreground "green"))))
                      (message "%s"
                               (concat "rime inline ascii "
                                       (propertize "disabled" 'face '(:foreground "red"))))))))
  (setq default-input-method "rime")
  (setq rime-show-candidate 'posframe
        rime-librime-root (concat user-emacs-directory "librime/dist/")
        rime-user-data-dir (concat user-emacs-directory "rime/")
        rime-translate-keybindings
        '("C-f" "C-b" "C-n" "C-p" "C-g" "C-`")
        rime-show-preedit 'inline
        rime-disable-predicates
        '(
          rime-predicate-prog-in-code-p
          rime-predicate-org-in-src-block-p
          rime-predicate-current-uppercase-letter-p
          rime-predicate-after-alphabet-char-p
          rime-predicate-after-ascii-char-p
          rime-predicate-evil-mode-p
          rime-predicate-hydra-p
          rime-predicate-punctuation-line-begin-p
          rime-predicate-space-after-cc-p
          rime-predicate-tex-math-or-command-p
          ;; meow-normal-mode-p
          ;; meow-motion-mode-p
          ;; meow-keypad-mode-p
          ))

  (setq rime-posframe-properties
        (list :font "LXGW WenKai"
              ;; :background (face-background 'mode-line)
              :internal-border-width 1))
#+END_SRC
** Org mode

*** Define seperate font for org mode

The hook for =variable-pitch-mode= is moved to session [[*Beautify]] since the sequence of mode loading should be well taken care of.

#+BEGIN_SRC emacs-lisp
  (when (boundp 'lt-font)
   (defface lt-font
     `((t :family ,lt-font))
     "Font for literature"
     :group 'basic-faces))
  (set-face-attribute 'variable-pitch nil
                      :family (face-attribute 'lt-font :family))
  (defun buffer-toggle-highlight-foreground (&optional args)
    (interactive)
    (if (and (boundp 'face-remap-add-relative-cookie) face-remap-add-relative-cookie)
        (progn (face-remap-remove-relative face-remap-add-relative-cookie)
               (setq face-remap-add-relative-cookie nil))
      (set (make-local-variable 'face-remap-add-relative-cookie) (face-remap-add-relative 'default '(:foreground "#000000")))))
#+END_SRC

*** Enable Large Titles

#+begin_src emacs-lisp
  (setq org-level-color-stars-only nil)
#+end_src

***  Table Align

#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'valign)
#+END_SRC

*** Org Download

#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'org-download)
  (add-hook 'org-mode-hook 'org-download-enable)
  (with-eval-after-load 'org
   (define-key org-mode-map (kbd "C-c C-v") 'org-download-clipboard))
#+END_SRC

*** Quick jump to specific headline via ivy and fuzzy search

It will be helpful to jump quickly when editing ~conf.org~.
Also see [[https://github.com/abo-abo/swiper/issues/986][discussion]].

#+BEGIN_SRC emacs-lisp
  (setq org-goto-interface 'outline-path-completion)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

I use ~"C-j"~ to invoke jump.

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-j") 'org-goto))
#+END_SRC


*** Latex Editing

#+BEGIN_SRC emacs-lisp :tangle no
  (with-eval-after-load 'org
    ;; Linux cannot handle latex fragment properly
    (if (eq system-type 'gnu/linux)
        (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0)))
    (setq org-preview-latex-default-process 'dvisvgm
          org-image-actual-width (list 250))
    (require 'latex))

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((latex . t)))

  ;; (if (eq system-type 'gnu/linux)
  ;;  (setq org-latex-create-formula-image-program 'imagemagick))
  ;; (setq org-highlight-latex-and-related '(latex))

  ;; (defun wrap-region-with-added (&optional args)
  ;;   "wrap `region' with [[changes:added][`region']]"
  ;;   (interactive)
  ;;   (when (region-active-p)
  ;;     (let ((BEG (region-beginning))
  ;;           (END (region-end)))
  ;;       (setq mark-active nil)
  ;;       (goto-char END)
  ;;       (insert "]]")
  ;;       (goto-char BEG)
  ;;       (insert "[[changes:added]["))))
#+END_SRC


*** Fill paragraph

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook #'toggle-truncate-lines)
  (defun fill-paragraph-ospl (&optional P)
    "When called with prefix argument call `fill-paragraph'.
  Otherwise split the current paragraph into one sentence per line."
    (interactive "P")
    (if (not P)
        (save-excursion
          (let ((fill-column 12345678)) ;; relies on dynamic binding
            (fill-paragraph) ;; this will not work correctly if the paragraph is
            ;; longer than 12345678 characters (in which case the
            ;; file must be at least 12MB long. This is unlikely.)
            (let ((end (save-excursion
                         (end-of-line 1)
                         (point-marker)))   ;; remember where to stop
                  (indent (pcase major-mode
                            ('org-mode 'org-indent-line)
                            ('markdown-mode 'markdown-indent-line)
                            ('LaTeX-mode 'LaTeX-indent-line)
                            (otherwise nil))))
              (beginning-of-line)
              (while (progn (forward-sentence)
                            (< (point) (marker-position end)))
                (just-one-space) ;; leaves only one space, point is after it
                (delete-char -1) ;; delete the space
                (newline)        ;; and insert a newline
                (when indent (funcall indent))))))
      ;; otherwise do ordinary fill paragraph
      (fill-paragraph P)))
  (with-eval-after-load 'org
   (define-key org-mode-map (kbd "M-q") 'fill-paragraph-ospl))
#+END_SRC

*** Local Functions

#+BEGIN_SRC emacs-lisp
  (defun org-copy-src-block-link()
    (interactive)
    (save-excursion
      (forward-line -1)
      (org-edit-src-code)
      (clipboard-kill-ring-save (point-min) (point-max))
      (org-edit-src-exit)))
#+END_SRC

*** Beautify

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'org
    ;; Make verbatim with highlight text background.
    (add-to-list 'org-emphasis-alist
                 `("=" (:background ,(face-background 'org-block)
                                    ,(face-attribute 'cc-font :family)
                                    )))
    ;; Make deletion(obsolote) text foreground with dark gray.
    (add-to-list 'org-emphasis-alist
                 '("+" (:foreground "dark gray"
                                    :strike-through t)))
    ;; Make code style around with box.
    (add-to-list 'org-emphasis-alist
                 '("~" (:box (:line-width 1
                                          :color "grey75"
                                          :style released-button))))
    (setq org-hide-emphasis-markers t
          org-pretty-entities t))

  ;; (with-eval-after-load 'org-indent
  ;;   (set-face-attribute 'org-indent nil
  ;;                       :background (face-background 'line-number)))

  (with-eval-after-load 'whitespace
    (dolist (face '(whitespace-space whitespace-tab whitespace-newline))
      (set-face-attribute face nil
                          :background (face-background 'default)
                          :foreground "grey75")))
  (init/ensure-package-lazy 'org-modern)
  (when (display-graphic-p)
    (with-eval-after-load 'org
     (add-hook-lambda org-mode-hook
                      (variable-pitch-mode)
                      ;; (org-indent-mode)
                      (org-modern-mode))))
  ;; (setq org-ellipsis "  ⇲")
#+END_SRC
*** Completion

Disable completion backends other than =company-files=.
Turn on yasnippet mode.

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (require 'org-tempo))
  (add-hook-lambda org-mode-hook
                   (setq-local acm-enable-yas nil)
                   (setq-local yas-indent-line 'fixed))
#+end_src

*** Export

Define export processes
#+begin_src emacs-lisp
  (add-hook-lambda org-mode-hook
                   (setq-local compile-command
                               (concat "pandoc --pdf-engine=xelatex --toc -V mainfont=\'LXGW Wenkai Mono\' -o "
                                       (concat (file-name-sans-extension (buffer-name)) ".pdf ")
                                       (buffer-name))))
  (setq org-latex-pdf-process
        '("latexmk -f -pdf -%latex -interaction=nonstopmode -shell-escape -output-directory=%o %f"))
  (with-eval-after-load 'org
    (setq org-latex-default-packages-alist
          (remove '("AUTO" "inputenc" t)
                  org-latex-default-packages-alist)))
#+end_src

*** Preview

#+begin_src emacs-lisp
  (setq org-latex-create-formula-image-program 'imagemagick
        org-image-actual-width (list 250))
#+end_src

*** Babel

#+begin_src emacs-lisp
  (org-babel-do-load-languages 'org-babel-load-languages
                               '((shell . t)
                                 (python . t)))
#+end_src

** Latex

#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'auctex)
  (setq TeX-auto-save t
        TeX-parse-self t
        TeX-source-correlate-mode t
        TeX-source-correlate-start-server t
        TeX-source-correlate-method '((dvi . source-specials)
                                      (pdf . synctex)))
  (setq-default TeX-master nil)
  (with-eval-after-load 'latex
    (define-key tex-mode-map (kbd "M-q") 'fill-paragraph-ospl)
    (add-to-list
     'TeX-command-list
     '("XeLaTeX" "%`xelatex%(mode)%' %t" TeX-run-TeX nil t))
    (add-to-list
     'TeX-command-list
     '("Make" "make" TeX-run-compile nil t)))

#+END_SRC

***  External pdf viewer

=EAF= may be broken when the output file is being compiled.

#+begin_src emacs-lisp
  (setq TeX-source-correlate-mode t)
  (setq TeX-source-correlate-start-server t)
  (setq TeX-view-program-selection
        (quote
         ((output-pdf "Okular"))))
#+end_src
* Extra features
** Set up magit
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'magit)
#+END_SRC
** Eshell
*** Prompt
#+BEGIN_SRC emacs-lisp
  (defun hex-to-hsl (hex)
    "Convert hex string to hsl digits, the result is returned as list"
    (eval `(color-rgb-to-hsl ,@(mapcar
                                (lambda (x)
                                  (/ (float
                                      (string-to-number
                                       (substring hex (car x) (cadr x)) 16)) 256))
                                '((1 3) (3 5) (5 7))))))


  (defun make-color-lighter (hex factor)
    "Make hex color lighter, return string"
    (let ((hsl (hex-to-hsl hex)))
      (eval `(color-rgb-to-hex
              ,@(color-hsl-to-rgb (car hsl)
                                  (min (* (cadr hsl) factor) 1)
                                  (min (* (caddr hsl) factor) 1))
              2))))

  (defun shortened-path (path max-len)
    "Return a modified version of `path', replacing some components
        with single characters starting from the left to try and
        get the path down to `max-len'"
    (let* ((components (split-string (abbreviate-file-name path) "/"))
           (len (+ (1- (length components))
                   (cl-reduce '+ components :key 'length)))
           (str ""))
      (while (and (> len max-len)
                  (cdr components))
        (setq str (concat str (if (= 0 (length (car components)))
                                  "/"
                                (string (elt (car components) 0) ?/)))
              len (- len (1- (length (car components))))
              components (cdr components)))
      (concat str (cl-reduce (lambda (a b) (concat a "/" b)) components))))


  (setq eshell-prompt-function-light
          #'(lambda nil
              (concat
               (propertize "# "
                           'face `(:background (face-background 'default) :weight bold))
               (propertize (user-login-name)
                           'face `(:foreground ,(face-foreground 'font-lock-keyword-face) :weight bold))
               (propertize " at "
                           'face `(:background (face-background 'default)))
               (propertize (system-name)
                           'face `(:foreground  ,(face-foreground 'font-lock-builtin-face) :weight bold))
               (propertize " in "
                           'face `(:background (face-background 'default)))
               (propertize (shortened-path (eshell/pwd) 40)
                           'face `(:foreground ,(face-foreground 'font-lock-string-face) :weight bold :slant italic))
               (if (and (boundp 'url-proxy-services)
                        (assoc "http" url-proxy-services))
                   (concat
                    (propertize " via "
                                'face `(:background (face-background 'default)))
                    (propertize (cdr (assoc "http" url-proxy-services))
                                'face `(:foreground ,(face-foreground 'font-lock-doc-face) :weight bold))))
               (propertize "\n"
                           'face `(:background (face-background 'default)))
               (propertize "["
                           'face `(:background (face-background 'default) :weight bold))
               (propertize (if (= (user-uid) 0) "# " "λ")
                           'face `(:slant default :weight bold :foreground ,(face-foreground 'font-lock-constant-face)))
               (propertize "]"
                           'face `(:background (face-background 'default) :weight bold))
               (propertize " "
                           'face `(:background (face-background 'default))))))

  (setq eshell-prompt-regexp "^\\\[[#λ]\\\] ")
  (if (bound-and-true-p init/system-dark-modep)
      (setq eshell-prompt-function
            eshell-prompt-function-dark)
    (setq eshell-prompt-function
          eshell-prompt-function-light))
#+END_SRC
This is just for ~shell~ command
#+BEGIN_SRC emacs-lisp
  (setq comint-prompt-read-only t)
#+END_SRC
*** Syntax highlight
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'eshell-syntax-highlighting)
  (with-eval-after-load 'eshell
    (require 'eshell-syntax-highlighting)
    (set-face-attribute 'eshell-syntax-highlighting-alias-face
                        nil :weight 'bold)
    (set-face-attribute 'eshell-syntax-highlighting-shell-command-face
                        nil :weight 'bold)
    (unless (bound-and-true-p init/system-dark-modep)
      (progn (set-face-foreground 'eshell-syntax-highlighting-alias-face "#2E67D3")
             (set-face-foreground 'eshell-syntax-highlighting-shell-command-face "#2E67D3")))
    (add-hook 'eshell-mode-hook 'eshell-syntax-highlighting-mode))
#+END_SRC
*** FZF fuzzy search
#+BEGIN_SRC emacs-lisp
  (setq eshell-history-size 1024)
  (defun init/ivy-eshell-history ()
    (interactive)
    (require 'em-hist)
    (let* ((start-pos (save-excursion (eshell-bol) (point)))
           (end-pos (point))
           (input (buffer-substring-no-properties start-pos end-pos))
           (command (ivy-read "Command: "
                              (delete-dups
                               (when (> (ring-size eshell-history-ring) 0)
                                 (ring-elements eshell-history-ring)))
                              :initial-input input)))
      (setf (buffer-substring start-pos end-pos) command)
      (end-of-line)))
#+END_SRC
*** z-jump
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'eshell-z)
  (with-eval-after-load 'eshell
    (require 'eshell-z))
  ;; (add-hook 'eshell-mode-hook
  ;;           #'(lambda ()
  ;;               (require 'eshell-z)))
#+END_SRC
*** Colorful ~cat~
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'em-unix
    (defun eshell/cat (&rest args)
      "Like cat(1) but with syntax highlighting."
      (unless args (error "Usage: cat FILE ..."))
      (dolist (filename (eshell-flatten-list args))
        (let ((existing-buffer (get-file-buffer filename))
              (buffer (find-file-noselect filename)))
          (eshell-print
           (with-current-buffer buffer
             (if (fboundp 'font-lock-ensure)
                 (font-lock-ensure)
               (with-no-warnings
                 (font-lock-fontify-buffer)))
             (buffer-string)))
          (unless existing-buffer
            (kill-buffer buffer))
          nil))))
#+END_SRC
*** image cat
#+BEGIN_SRC emacs-lisp
  (defun eshell/imgcat (&rest args)
    "Display image files."
    (unless args (error "Usage: imgcat FILE ..."))
    (dolist (img (eshell-flatten-list args))
      (eshell/printnl
       (propertize " " 'display (create-image img)))))
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (add-hook-lambda eshell-mode-hook
                   (local-set-key (kbd "C-r") #'init/ivy-eshell-history))
#+END_SRC
*** Alias
#+BEGIN_SRC emacs-lisp
  (defun eshell/emacs (file)
    (find-file file))
  (defun eshell/vim (file)
    (find-file file))
#+END_SRC

*** Issues
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'em-term
    (push "ghci" eshell-visual-commands)
    (push "ssh" eshell-visual-commands)
    (push "htop" eshell-visual-commands)
    (add-hook-lambda eshell-mode-hook
                     (setq-local corfu-auto nil)))
#+END_SRC
*** Eshell toggle
#+begin_src emacs-lisp
  (init/ensure-package-lazy 'eshell-toggle)
  (global-set-key (kbd "M-e") 'eshell-toggle)
#+end_src

#+BEGIN_SRC emacs-lisp
  (defun eshell-project ()
    (interactive)
    (let ((eshell-name (eshell-toggle--make-buffer-name)))
      (unless (gnus-buffer-live-p eshell-name)
        (eshell-toggle--new-buffer eshell-name))
      (switch-to-buffer eshell-name)))
#+END_SRC
** Compile

#+begin_src emacs-lisp
  (with-eval-after-load 'compile
    (define-key prog-mode-map (kbd "C-c C-c") #'compile)
    (require 'ansi-color)
    (defun colorize-compilation-buffer ()
      (toggle-read-only)
      (ansi-color-apply-on-region compilation-filter-start (point))
      (toggle-read-only))
    (add-hook 'compilation-filter-hook 'colorize-compilation-buffer))
#+end_src

** Shell
#+begin_src emacs-lisp
  (add-hook-lambda shell-mode-hook
                   (setq-local corfu-auto nil)
                   (compilation-shell-minor-mode +1))
#+end_src
** Symbol overlay
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'symbol-overlay)
  (global-set-key (kbd "M-i") 'symbol-overlay-put)
  (global-set-key (kbd "M-n") 'symbol-overlay-switch-forward)
  (global-set-key (kbd "M-p") 'symbol-overlay-switch-backward)
  (global-set-key (kbd "M-k") 'symbol-overlay-remove-all)
  (add-hook-lambda (prog-mode-hook conf-mode-hook yaml-mode-hook)
                        (symbol-overlay-mode))
#+END_SRC


** EAF

Install all packages.

#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (add-to-list 'load-path
               (concat user-emacs-directory
                       "site-packages/eaf"))
  (setq eaf-python-command "/usr/bin/python3")
  (require 'eaf)
  (require 'eaf-pdf-viewer)
  ;; (require 'eaf-system-monitor)
  (require 'eaf-image-viewer)
  ;; (require 'eaf-markdown-previewer)
  ;; (require 'eaf-org-previewer)
  ;; (require 'eaf-file-manager)
  (require 'eaf-all-the-icons)
  ;; (require 'eaf-browser)
  (require 'eaf-org)
#+end_src

Configure the package with a more emacs-like keybindings.

#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (eaf-bind-key scroll_to_begin "M-<" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_to_end "M->" eaf-pdf-viewer-keybinding)
#+end_src

*** Configure pdf-viewer

Configure latex preview.

#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (with-eval-after-load 'latex
   (add-to-list 'TeX-view-program-list '("eaf" eaf-pdf-synctex-forward-view))
   (add-to-list 'TeX-view-program-selection '(output-pdf "eaf")))
#+end_src

Change background color.

#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (setq eaf-pdf-dark-mode nil)
  (setq eaf-buffer-background-color (face-background 'default))
#+end_src

Emacs style keybindings
#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (eaf-bind-key scroll_to_begin "M-<" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_to_end "M->" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_up "n" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_down "p" eaf-pdf-viewer-keybinding)
  (eaf-bind-key jump_to_page "j" eaf-pdf-viewer-keybinding)
#+end_src

Use native search method

#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (add-hook-lambda eaf-mode-hook
                   (ctrlf-local-mode -1))
#+end_src

*** Pdf-tools

#+begin_src emacs-lisp
  (init/ensure-package-lazy 'pdf-tools)
  (pdf-loader-install)
  (setq pdf-view-use-scaling t)
  ;; Use pdf-tools to open PDF files
  (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
        TeX-source-correlate-start-server t)
  ;; Update PDF buffers after successful LaTeX runs
  (add-hook 'TeX-after-compilation-finished-functions
            #'TeX-revert-document-buffer)
  (with-eval-after-load 'pdf-tools
    (define-key pdf-view-mode-map (kbd "j") #'pdf-view-next-line-or-next-page)
    (define-key pdf-view-mode-map (kbd "k") #'pdf-view-previous-line-or-previous-page))
#+end_src

Restore session

#+begin_src emacs-lisp
  ;; workaround for pdf-tools not reopening to last-viewed page of the pdf:
  ;; https://github.com/politza/pdf-tools/issues/18#issuecomment-269515117
  (defun brds/pdf-set-last-viewed-bookmark ()
    (interactive)
    (when (eq major-mode 'pdf-view-mode)
      (bookmark-set (brds/pdf-generate-bookmark-name))))

  (defun brds/pdf-jump-last-viewed-bookmark ()
    (bookmark-set "fake") ; this is new
    (when
        (brds/pdf-has-last-viewed-bookmark)
      (bookmark-jump (brds/pdf-generate-bookmark-name))))

  (defun brds/pdf-has-last-viewed-bookmark ()
    (assoc
     (brds/pdf-generate-bookmark-name) bookmark-alist))

  (defun brds/pdf-generate-bookmark-name ()
    (concat "PDF-LAST-VIEWED: " (buffer-file-name)))

  (defun brds/pdf-set-all-last-viewed-bookmarks ()
    (dolist (buf (buffer-list))
      (with-current-buffer buf
        (brds/pdf-set-last-viewed-bookmark))))

  (add-hook 'kill-buffer-hook 'brds/pdf-set-last-viewed-bookmark)
  (add-hook 'pdf-view-mode-hook 'brds/pdf-jump-last-viewed-bookmark)
  (unless noninteractive  ; as `save-place-mode' does
    (add-hook 'kill-emacs-hook #'brds/pdf-set-all-last-viewed-bookmarks))
#+end_src

*** Configure Browser
#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (if (bound-and-true-p init/local-proxies)
      (let ((http_proxy (cdr (assoc "http" init/local-proxies))))
        (if http_proxy
         (progn
           (setq eaf-proxy-type "http")
           (setq eaf-proxy-host (car (split-string http_proxy ":")))
           (setq eaf-proxy-port (cadr (split-string http_proxy ":")))))))
#+end_src

*** Configure previewer
#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (defun preview-current-buffer (&optional args)
    (interactive)
    (eaf-open (buffer-file-name (current-buffer))))
#+end_src

*** Integration with org-mode

#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (defun eaf-org-open-file (file &optional link)
    "An wrapper function on `eaf-open'."
    (eaf-open file))

  ;; use `emacs-application-framework' to open PDF file: link
  (with-eval-after-load 'org
    (add-to-list 'org-file-apps '("\\.pdf\\'" . eaf-org-open-file))
    (add-to-list 'org-file-apps '("\\.jpeg\\'" . eaf-org-open-file))
    (add-to-list 'org-file-apps '("\\.jpg\\'" . eaf-org-open-file))
    (add-to-list 'org-file-apps '("\\.png\\'" . eaf-org-open-file)))
#+end_src
** lua-mode
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'lua-mode)
#+END_SRC
** scala-mode
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'scala-mode)
#+END_SRC
** markdown-mode
#+begin_src emacs-lisp
  (init/ensure-package-lazy 'markdown-mode)
  (with-eval-after-load 'markdown-mode
    (define-key markdown-mode-map (kbd "M-q") 'fill-paragraph-ospl)
    (add-hook-lambda markdown-mode-hook
                     (variable-pitch-mode)))
#+end_src
** ebib

#+BEGIN_SRC emacs-lisp :tangle (if (and (boundp 'init/ebib-file-search-dirs) (boundp 'init/ebib-preload-bib-files)) "yes" "no")
  (init/ensure-package-lazy 'ebib)
  (setq ebib-file-search-dirs init/ebib-file-search-dirs)
  (setq ebib-preload-bib-files init/ebib-preload-bib-files)
  (setq ebib-index-columns '(("Entry Key" 20 t)
                             ("Title" 60 t)
                             ("Author/Editor" 20 t)
                             ("Journal" 30 t)
                             ("Year" 6 t)))
  (setq ebib-index-column-separator "  ")
  (with-eval-after-load 'ebib
    (require 'org-ebib)
    (setq ebib-file-associations nil)
    (setq ebib-pdf-external
          (cl-case system-type
            ('darwin "open")
            ('gnu/linux "xdg-open")
            (t nil)))
    (define-key ebib-index-mode-map (kbd "F") (lambda () (interactive)
                                                 (let ((ebib-file-associations `(("pdf" . ,ebib-pdf-external))))
                                                   (call-interactively 'ebib-view-file)))))
  (global-set-key (kbd "C-c e i") 'ebib-insert-citation)
  (switch-to-tab-before ebib "ebib")
  (execute-command-in ebib (car init/ebib-file-search-dirs))
#+END_SRC
** Org Roam
#+BEGIN_SRC emacs-lisp :tangle (if (boundp 'init/org-roam-directory) "yes" "no")
  (init/ensure-package-lazy 'org-roam)
  (setq org-roam-directory init/org-roam-directory)
  (defun org-roam-node-find (&optional args)
    "Lazy load wrapper for org-roam"
    (interactive)
    (require 'org-roam)
    (org-roam-setup)
    (org-roam-node-find))
  (defun org-roam-node-insert (&optional args)
    "Lazy load wrapper for org-roam"
    (interactive)
    (require 'org-roam)
    (org-roam-setup)
    (org-roam-node-insert))
  (defun org-roam-node-list (&optional args)
    "Lazy load wrapper for org-roam"
    (interactive)
    (require 'org-roam)
    (org-roam-setup)
    (org-roam-node-list))
  (global-set-key (kbd "C-c n f") #'org-roam-node-find)
  (global-set-key (kbd "C-c n i") #'org-roam-node-insert)
  (global-set-key (kbd "C-c n l") #'org-roam-buffer-list)
#+END_SRC

** Org Drill
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'org-drill)
  (defun org-find-drill-file ()
    (interactive)
    (find-file init/org-drill-file))
#+END_SRC
** English Helper
#+begin_src emacs-lisp
  (add-to-list 'load-path
               (concat user-emacs-directory "site-packages/corfu-english-helper"))
  (defun toggle-corfu-english-helper (&optional args)
      "Lazy load wrapper for english helper"
      (interactive)
      (require 'corfu-english-helper)
      (toggle-corfu-english-helper))
#+end_src
** Ripgrep
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'rg)
  (defun rg (&optional args)
    "Lazy load wrapper for rg"
    (interactive)
    (require 'rg)
    (call-interactively 'rg))
#+END_SRC
** IBuffer
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'all-the-icons-ibuffer)
  (init/ensure-package-lazy 'ibuffer-project)
  (setq-default ibuffer-project-use-cache t)
  (global-set-key (kbd "C-x C-b") #'ibuffer)
  (add-hook-lambda ibuffer-hook
                   (all-the-icons-ibuffer-mode)
                   (setq ibuffer-filter-groups (ibuffer-project-generate-filter-groups))
                   (unless (eq ibuffer-sorting-mode 'alphabetic)
                     (ibuffer-do-sort-by-alphabetic)))
  (with-eval-after-load 'ibuffer
    (require 'all-the-icons-ibuffer)
    (require 'ibuffer-project))
#+END_SRC
** Dired
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'fd-dired)
  (add-to-list 'load-path
               (concat user-emacs-directory "site-packages/diredp"))
  (setq-default diredp-hide-details-initially-flag nil)
  (with-eval-after-load 'dired
    (require 'dired-x)
    (require 'dired+))
  (when (string= system-type "darwin")
    (setq dired-use-ls-dired nil))
  (setq dired-omit-files "^\\\.")
  (add-hook 'dired-mode-hook #'dired-omit-mode)
  (define-key dired-mode-map (kbd "C-c t") #'dired-omit-mode)
  (setq-default dired-listing-switches "-alh")
#+END_SRC

#+begin_src emacs-lisp
  (defun dired-insert-kill-current-dir (DIRNAME)
    (interactive
     (list (dired-get-filename)))
    (call-interactively 'dired-prev-subdir)
    (dired-kill-subdir)
    (dired-insert-subdir DIRNAME))
  (define-key dired-mode-map (kbd "I") 'dired-insert-kill-current-dir)
#+end_src

#+begin_src emacs-lisp
  (defun open-in-external-app (&optional @fname)
    "Open the current file or dired marked files in external app.
  When called in emacs lisp, if @fname is given, open that."
    (interactive)
    (let* (
           ($file-list
            (if @fname
                (progn (list @fname))
              (if (string-equal major-mode "dired-mode")
                  (dired-get-marked-files)
                (list (buffer-file-name)))))
           ($do-it-p (if (<= (length $file-list) 5)
                         t
                       (y-or-n-p "Open more than 5 files? "))))
      (when $do-it-p
        (cond
         ((string-equal system-type "darwin")
          (mapc
           (lambda ($fpath)
             (call-process "open" nil 0 nil $fpath))  $file-list))
         ((string-equal system-type "gnu/linux")
          (mapc
           (lambda ($fpath)
             (call-process "xdg-open" nil 0 nil $fpath))
           $file-list))))))

  (defun xah-show-in-desktop ()
    "Show current file in desktop.
   (Mac Finder, File Explorer, Linux file manager)
  This command can be called when in a file buffer or in `dired'.
  URL `http://xahlee.info/emacs/emacs/emacs_dired_open_file_in_ext_apps.html'
  Version 2020-11-20 2021-01-18"
    (interactive)
    (let (($path (if (buffer-file-name) (buffer-file-name) default-directory)))
      (cond
       ((string-equal system-type "windows-nt")
        (shell-command (format "PowerShell -Command Start-Process Explorer -FilePath %s" (shell-quote-argument default-directory)))
        ;; todo. need to make window highlight the file
        )
       ((string-equal system-type "darwin")
        (if (eq major-mode 'dired-mode)
            (let (($files (dired-get-marked-files )))
              (if (eq (length $files) 0)
                  (shell-command (concat "open " (shell-quote-argument (expand-file-name default-directory ))))
                (shell-command (concat "open -R " (shell-quote-argument (car (dired-get-marked-files )))))))
          (shell-command
           (concat "open -R " (shell-quote-argument $path)))))

       ((string-equal system-type "gnu/linux")
        (let (
              (process-connection-type nil)
              (openFileProgram (if (file-exists-p "/usr/bin/gvfs-open")
                                   "/usr/bin/gvfs-open"
                                 "/usr/bin/xdg-open")))
          (start-process "" nil openFileProgram (shell-quote-argument $path)))
        ;; (shell-command "xdg-open .") ;; 2013-02-10 this sometimes froze emacs till the folder is closed. eg with nautilus
        ))))


  (define-key dired-mode-map [remap browse-url-of-dired-file] 'open-in-external-app)
  ;; Most case "W"
  (define-key dired-mode-map (kbd "C-^") 'xah-show-in-desktop)
#+end_src
** Word Count
#+BEGIN_SRC emacs-lisp
  (defvar words-count-rule-chinese "\\cc"
    "A regexp string to match Chinese characters.")

  (defvar words-count-rule-nonespace "[^[:space:]]"
    "A regexp string to match none pace characters.")

  (defvar words-count-rule-ansci "[A-Za-z0-9][A-Za-z0-9[:punct:]]*"
    "A regexp string to match none pace characters.")

  (defvar words-count-regexp-list
    (list words-count-rule-chinese
          words-count-rule-nonespace
          words-count-rule-ansci)
    "A list for the regexp used in `advance-words-count'.")

  (defvar words-count-message-func 'message--words-count
    "The function used to format message in `advance-words-count'.")

  (defun special--words-count (start end regexp)
    "Count the word from START to END with REGEXP."
    (let ((count 0))
      (save-excursion
        (save-restriction
          (goto-char start)
          (while (and (< (point) end) (re-search-forward regexp end t))
            (setq count (1+ count)))))
      count))
  (defun message--words-count (list start end)
    "Display the word count message.
  Using the LIST passed form `advance-words-count'. START & END are
  required to call extra functions, see `count-lines' &
  `count-words'. When ARG is specified, display a verbose buffer."
    (message
     (format
      "
  -----------~*~ Words Count ~*~---------
   Word Count .................... %d
   Characters (without Space) .... %d
   Characters (all) .............. %d
   Number of Lines ............... %d
   ANSCII Chars .................. %d
  %s
  =======================================
  "
      (+ (car list) (car (last list)))
      (cadr list)
      (- end start)
      (count-lines start end)
      (car (last list))
      (concat
       (unless (= 0 (car list))
         (format " Chinese Chars ................. %d\n"
                 (car list)))
       (format " English Words ................. %d\n"
               (count-words start end))))
     nil nil nil -1))

  ;;;###autoload
  (defun advance-words-count (beg end)
    "Chinese user preferred word count.
  If BEG = END, count the whole buffer. If called initeractively,
  use minibuffer to display the messages. The optional ARG will be
  passed to `message--words-count'.

  See also `special-words-count'."
    (interactive (if (use-region-p)
                     (list (region-beginning)
                           (region-end))
                   (list nil nil)))
    (let ((min (or beg (point-min)))
          (max (or end (point-max)))
          list)
      (setq list
            (mapcar
             (lambda (r) (special--words-count min max r))
             words-count-regexp-list))
      (if (called-interactively-p 'any)
          (message--words-count list min max)
        list)))
#+END_SRC
** Setup hideshow
#+BEGIN_SRC emacs-lisp
  (require 'hideshow)
  (add-hook 'prog-mode-hook 'hs-minor-mode)
  (defun hs-toggle-hiding-or-indent-for-tab-command (&optional arg)
    (interactive "P")
    (let ((oldpos (point)))
      (back-to-indentation)
      (if (and
           (not (region-active-p))
           (hs-looking-at-block-start-p))
          (hs-toggle-hiding)
        (progn
          (goto-char oldpos)
          (indent-for-tab-command arg)))))
  (define-key hs-minor-mode-map (kbd "TAB") #'hs-toggle-hiding-or-indent-for-tab-command)
#+END_SRC
Make the overlay look nicer
#+BEGIN_SRC emacs-lisp
  (defconst hideshow-folded-face '((t (:inherit 'font-lock-comment-face :box t))))
  (defun hideshow-folded-overlay-fn (ov)
    (when (eq 'code (overlay-get ov 'hs))
      (let* ((nlines (count-lines (overlay-start ov) (overlay-end ov)))
             (info (format " ... #%d " nlines)))
        (overlay-put ov 'display (propertize info 'face hideshow-folded-face)))))
  (setq hs-set-up-overlay 'hideshow-folded-overlay-fn)
#+END_SRC

** Tramp
#+begin_src emacs-lisp
  (setq-default tramp-verbose 1)
  (setq-default tramp-default-method "sshx")
#+end_src
** Enable disabled feature
#+begin_src emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
#+end_src

** Telega
#+begin_src emacs-lisp
  (init/ensure-package-lazy 'telega)
  (setq telega-symbol-telegram nil)
  (with-eval-after-load 'telega
    (add-hook 'telega-root-mode-hook 'hl-line-mode)
    (setq telega-chat-button-width 20)
    (setq telega-root-fill-column (+ 20 telega-chat-button-width))
    (setq switch-to-buffer-preserve-window-point t)
    (setq telega-chat--display-buffer-action
          '((display-buffer-reuse-window display-buffer-use-some-window)))
    (define-key telega-chat-mode-map [remap telega-msg-resend] 'telega-msg-forward-marked-or-at-point)
    (define-key telega-msg-button-map (kbd "SPC") nil)
    (define-key telega-msg-button-map (kbd "k") nil)
    (define-key telega-msg-button-map (kbd "h") nil)
    (define-key telega-msg-button-map (kbd "l") nil))
  (if (bound-and-true-p init/local-proxies)
      (let ((http_proxy (cdr (assoc "http" init/local-proxies))))
        (if http_proxy
            (setq telega-proxies
                  (list
                   `(:server
                     ,(car (split-string http_proxy ":"))
                     :port
                     ,(string-to-number (cadr (split-string http_proxy ":")))
                     :enable t
                     :type (:@type "proxyTypeHttp")))))))
  ;; (add-hook-lambda telega-chat-mode-hook
  ;;                  (setq-local company-minimum-prefix-length 1)
  ;;                  (add-to-list (make-local-variable 'completion-at-point-functions)
  ;;                               (cape-company-to-capf 'telega-company-username)))
  (switch-to-tab-before telega "telega")
  (execute-command-in telega "~/.telega/")
#+end_src
** Wonderlust

#+begin_src emacs-lisp
  (init/ensure-package-lazy 'wanderlust)
  (if (boundp 'mail-user-agent)
      (setq mail-user-agent 'wl-user-agent))
  (if (fboundp 'define-mail-user-agent)
      (define-mail-user-agent
        'wl-user-agent
        'wl-user-agent-compose
        'wl-draft-send
        'wl-draft-kill
        'mail-send-hook))
#+end_src
** Vterm
#+begin_src emacs-lisp
  (init/ensure-package 'vterm)
  (define-key vterm-mode-map (kbd "C-y") 'vterm-send-C-S-v)
  (define-key vterm-mode-map (kbd "C-x C-q") 'vterm-copy-mode)
#+end_src
