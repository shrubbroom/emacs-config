#+TITLE: Configuration for Emacs
#+PROPERTY: header-args :results silent :tangle conf.el
#+BEGIN_SRC emacs-lisp
  ;;; conf.el --- Configuration generated by conf.org -*- lexical-binding: t; -*-
#+END_SRC
* Infrastructure

** Initialize packages

#+BEGIN_SRC emacs-lisp
  (package-initialize)
#+END_SRC
   
** User defined actions

User defined actions begin with =init=.

*** Auto install packages

#+BEGIN_SRC emacs-lisp
  (defun init/ensure-package (pkg)
    "ensure that package is installed, require it"
    (if (ignore-errors (require pkg))
        t
      (progn
        (unless (package-installed-p pkg)
          (package-refresh-contents)
          (package-install pkg))
        (unless (ignore-errors (require pkg))
          nil
          ;; (warn (format "(init/ensure-package) feature %s doesn't exist" pkg))
          )
        nil)))
  (defun init/ensure-package-lazy (pkg)
    "ensure package is installed, donot require"
    (unless (package-installed-p pkg)
      (package-refresh-contents)
      (package-install pkg)))
#+END_SRC

*** Toggle sudo in a buffer

#+BEGIN_SRC emacs-lisp
  (require 'tramp)
  (defun init/toggle-sudo-in-current-buffer ()
    (interactive)
    (if (buffer-file-name)
        (let ((sudo-buffer (current-buffer)))
          (progn
            (find-file (concat "/sudo:root@localhost:/" (buffer-file-name)))
            (kill-buffer sudo-buffer)))))
#+END_SRC

*** Find ~init.el~

#+BEGIN_SRC emacs-lisp
  (defun init/find-init ()
    "Find default `init.el' file"
    (interactive) (find-file "~/.config/emacs/init.el"))
#+END_SRC

*** Find ~conf.org~

#+BEGIN_SRC emacs-lisp
  (defun init/find-conf ()
    "Find default `conf.org' file"
    (interactive) (find-file "~/.config/emacs/conf.org"))
#+END_SRC

*** Open file in external applications

#+BEGIN_SRC emacs-lisp
  (defun init/open-file-in-external-application (&optional args)
    "Open current buffer in external applications"
    (interactive)
    (ivy-read "Type"
              '("File" "Dir")
              :action #'open-file-in-external-application-action))
  (pcase system-type
    ('darwin
     (defun open-file-in-external-application-action (arg)
      (if (buffer-file-name)
          (pcase arg
            ("Dir" (async-shell-command (concat "open " "\"" default-directory "\"")))
            ("File" (async-shell-command (concat "open " "\"" (buffer-file-name) "\""))))
        (message "The buffer is not a file"))))
    ('gnu/linux
     (defun open-file-in-external-application-action (arg)
      (if (buffer-file-name)
          (pcase arg
            ("Dir" (async-shell-command (concat "xdg-open " "\"" default-directory "\"")))
            ("File" (async-shell-command (concat "xdg-open " "\"" (buffer-file-name) "\""))))
        (message "The buffer is not a file")))))
#+END_SRC

*** Toggle proxy

The proxy is turned on iff. =init/local-proxies= is defined in =local-variables.el=.

#+BEGIN_SRC emacs-lisp :tangle (if (boundp 'init/local-proxies) "yes" "no")
  (defun init/toggle-url-proxy ()
    "Toggle proxy for the url.el library."
    (interactive)
    (cond
     (url-proxy-services
      (message "Turn off URL proxy")
      (setq url-proxy-services nil))
     (t
      (message "Turn on URL proxy")
      (setq url-proxy-services init/local-proxies))))
#+END_SRC

*** Highlight actions

These actions are done with package =pulse.el=.

#+begin_src emacs-lisp
  (require 'pulse)
#+end_src
**** Highlight =yank= actions

#+begin_src emacs-lisp
  (defun yank-pulse-advice (orig-fn &rest args)
    ;; Define the variables first
    (let (begin end)
      ;; Initialize `begin` to the current point before pasting
      (setq begin (point))
      ;; Forward to the decorated function (i.e. `yank`)
      (apply orig-fn args)
      ;; Initialize `end` to the current point after pasting
      (setq end (point))
      ;; Pulse to highlight!
      (pulse-momentary-highlight-region begin end)))
  (advice-add 'yank :around #'yank-pulse-advice)
#+end_src


**** Highlight after window switching

#+begin_src emacs-lisp
  (dolist (cmd
           '(other-window
             sort-tab-select-next-tab
             sort-tab-select-prev-tab
             recenter-top-bottom
             org-goto
             push-button
             symbol-overlay-jump-call
             ace-windowp))
    (advice-add cmd :after #'(lambda (&rest _)
                               (pulse-momentary-highlight-one-line))))

#+end_src
** Default behaviors

*** Use 4 spaces instead of tab

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

*** Save cursor position in file

#+BEGIN_SRC emacs-lisp
  (save-place-mode)
#+END_SRC

*** Set cursor style and enable blinking

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook (lambda () (setq cursor-type '(bar . 3))))
  (blink-cursor-mode -1)
#+end_src

*** Go to first char instead of line head

#+BEGIN_SRC emacs-lisp
  (defun smart-beginning-of-line ()
    "Move point to first non-whitespace character or beginning-of-line.
  Move point to the first non-whitespace character on this line.
  If point is already at that position, move point to the beginning of line."
    (interactive)
    (let ((oldpos (point)))
      (back-to-indentation)
      (and (= oldpos (point))
           (beginning-of-line))))
  (global-set-key [home] 'smart-beginning-of-line)
  (global-set-key "\C-a" 'smart-beginning-of-line)
#+END_SRC

*** Enable CUA selection mode (delete on selection)

#+BEGIN_SRC emacs-lisp
  (setq cua-delete-selection t)
  (cua-selection-mode t)
  (set-face-attribute 'cua-rectangle nil :background (face-background 'region))
#+END_SRC

*** Set frame title

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format '(:eval
                             (buffer-name)))
#+END_SRC

*** Disable visible warning and cursor

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
  (setq visible-bell nil
        visible-cursor nil
        ring-bell-function 'ignore)
#+END_SRC

*** Use y/n instead of yes/no

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Follow symbolic link by default
#+begin_src emacs-lisp
  (setq vc-follow-symlinks t)
#+end_src

*** Disable annoying ~$FILENAME~~

#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
#+END_SRC

*** Setup initial buffer

#+BEGIN_SRC emacs-lisp
  (setq-default initial-scratch-message "")
  (add-hook 'emacs-startup-hook (lambda ()
                                  (switch-to-buffer "*scratch*")
                                  (goto-char (point-min))
                                  (insert (concat ";; start up cost: "
                                                  (emacs-init-time)
                                                  "\n\n"))))
#+END_SRC

*** Define path

=init/define-path= is the function used to setup environment variables
of Emacs. For example (this function is not tangled)

#+begin_src emacs-lisp :tangle no
  (defun init/define-path ()
    "Example of `init/define-path', this function is not tangled"
    (custom-set-variables
     '(conda-anaconda-home "~/.local/miniconda3"))
    (add-to-list 'exec-path "~/.cargo/bin")
    (setenv "RUSTUP_DIST_SERVER" "https://example.com")
    (if init/local-proxies
        (progn
          (setenv "socks5_proxy" "socks5://localhost:1234")
          (setenv "http_proxy" "http://localhost:1234")
          (setenv "https_proxy" (getenv "http_proxy"))
          (setenv "all_proxy" (getenv "http_proxy"))))
    (setenv "PATH" (mapconcat 'identity exec-path ":")))
#+end_src

#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'init/define-path) "yes" "no")
  (init/define-path)
#+END_SRC

*** Disable suspend-frame

#+begin_src emacs-lisp
  (global-unset-key (kbd "C-z"))
#+end_src
** Navigation & Searching system
*** Basic packages

#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'ivy)
  ;; (init/ensure-package 'swiper)
  (init/ensure-package 'counsel)
  (init/ensure-package 'ivy-prescient)
#+END_SRC

*** Configure ivy

**** Hook at startup

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'ivy-mode)
#+END_SRC

**** Default variables

#+BEGIN_SRC emacs-lisp
  (setq-default ivy-use-virtual-buffers t
                ivy-virtual-abbreviate 'fullpath
                ivy-count-format "%-4d "
                ivy-magic-tilde nil
                ivy-dynamic-exhibit-delay-ms 150
                ivy-use-selectable-prompt t
                ivy-switch-buffer-faces-alist nil)
#+END_SRC

**** Issues

Enable ~escape~ as quit in ivy
#+BEGIN_SRC emacs-lisp
  (define-key ivy-minibuffer-map [escape] 'minibuffer-keyboard-quit)
#+END_SRC

*** Config ctrlf

#+BEGIN_SRC emacs-lisp :tangle no
  (define-key isearch-mode-map
    [remap isearch-delete-char]
    #'isearch-del-char)
  (setq isearch-lazy-count t)
  (setq lazy-count-prefix-format "%s/%s ")
  (setq lazy-highlight-cleanup t)
#+END_SRC

#+begin_src emacs-lisp
  (init/ensure-package-lazy 'ctrlf)
  (ctrlf-mode +1)
#+end_src
*** Configure counsel

**** Hook at startup

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'counsel-mode)
#+END_SRC

**** Default variables

#+BEGIN_SRC emacs-lisp
  (setq-default counsel-mode-override-describe-bindings t
                ivy-initial-inputs-alist '((Man-completion-table . "^")
                                           (woman . "^")))
#+END_SRC

**** Keybinding

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-x") 'counsel-M-x)
#+END_SRC

*** Configure ivy-prescient

~prescient~ is required for history look-up

#+BEGIN_SRC emacs-lisp
  (ivy-prescient-mode)
  (prescient-persist-mode +1)
#+END_SRC

** Project manager

The default project manager is built-in =project.el=.  The default
project finder is =find=.  We replece it with =fd= to speed up the
searching.

#+begin_src emacs-lisp
  (defun my/project-files-in-directory (dir)
    "Use `fd' to list files in DIR."
    (let* ((default-directory dir)
           (localdir (file-local-name (expand-file-name dir)))
           (command (format "fd -H -t f -0 . %s" localdir)))
      (project--remote-file-names
       (sort (split-string (shell-command-to-string command) "\0" t)
             #'string<))))

  (cl-defmethod project-files ((project (head local)) &optional dirs)
    "Override `project-files' to use `fd' in local projects."
    (mapcan #'my/project-files-in-directory
            (or dirs (list (project-root project)))))

#+end_src

The keymap starts with =C-c=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c p f") #'project-find-file)
  (global-set-key (kbd "C-c p b") #'project-switch-to-buffer)
  (global-set-key (kbd "C-c p g") #'project-switch-project)
#+END_SRC

** Helping System

*** Basic packages

#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'which-key)
  (init/ensure-package 'helpful)
#+END_SRC

*** Configurations

#+BEGIN_SRC emacs-lisp
  (which-key-mode 1)
  (setq counsel-describe-function-function #'helpful-callable
        counsel-describe-variable-function #'helpful-variable)
  (global-set-key (kbd "C-h k") #'helpful-key)
  (global-set-key (kbd "C-h d") #'helpful-at-point)
  (define-key helpful-mode-map (kbd "n") #'next-line)
  (define-key helpful-mode-map (kbd "p") #'previous-line)
  (define-key help-mode-map (kbd "n") #'next-line)
  (define-key help-mode-map (kbd "p") #'previous-line)
#+END_SRC

** Auto Save

#+begin_src emacs-lisp
  (add-to-list 'load-path
               (concat user-emacs-directory "site-packages/auto-save"))
  (require 'auto-save)
  (auto-save-enable)
  (setq auto-save-silent t)
#+end_src

** Window management

*** Buffer management

#+begin_src emacs-lisp
  (init/ensure-package 'buffer-move)
  (global-set-key (kbd "<C-S-up>")     'buf-move-up)
  (global-set-key (kbd "<C-S-down>")   'buf-move-down)
  (global-set-key (kbd "<C-S-left>")   'buf-move-left)
  (global-set-key (kbd "<C-S-right>")  'buf-move-right)

  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "<C-S-up>")     'buf-move-up)
    (define-key org-mode-map (kbd "<C-S-down>")   'buf-move-down)
    (define-key org-mode-map (kbd "<C-S-left>")   'buf-move-left)
    (define-key org-mode-map (kbd "<C-S-right>")  'buf-move-right))
#+end_src

*** Popup control

#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'popper)
  (init/ensure-package 'popper-echo)
  (setq popper-reference-buffers
        `("\\*Messages\\*"
          "Output\\*$"
          "\\*Async Shell Command\\*"
          help-mode
          helpful-mode
          compilation-mode
          Man-mode
          package-menu-mode
          pdf-outline-buffer-mode
          outline-mode))
  (global-set-key (kbd "<C-tab>") 'popper-toggle-latest)
  (define-key popper-mode-map (kbd "<C-tab>") 'popper-cycle)
  (global-set-key (kbd "<C-escape>") 'popper-kill-latest-popup)
  (popper-mode +1)
  (popper-echo-mode +1)
#+END_SRC

*** Window switching

#+begin_src emacs-lisp
  (init/ensure-package 'ace-window)
  (global-set-key [remap other-window] 'ace-window)
  (add-to-list 'aw-ignored-buffers "*sort-tab*")
  (add-to-list 'aw-ignored-buffers " SPEEDBAR")
  (setq aw-ignore-current nil)
#+end_src

#+begin_src emacs-lisp :tangle no
  (init/ensure-package 'switch-window)
  (global-set-key [remap other-window] 'switch-window)
  (setq switch-window-threshold 2)
  (setq switch-window-shortcut-appearance 'image)
#+end_src

*** Resize
#+begin_src emacs-lisp
  (defun transient-enlarge-window-horizontally ()
    "Transient version of `enlarge-window-horizontally"
    (interactive)
    (let ((echo-keystrokes nil))
      (enlarge-window-horizontally 1)
      (message "Resize: [{] Shrink-h, [}] Enlarge-h, [&] Shrink-v, [^] Enlarge-v")
      (set-transient-map
       (let ((map (make-sparse-keymap)))
         (define-key map [?{] #'shrink-window-horizontally)
         (define-key map [?}] #'enlarge-window-horizontally)
         (define-key map [?&] #'shrink-window)
         (define-key map [?^] #'enlarge-window)
         map)
       t)))

  (defun transient-shrink-window-horizontally ()
    "Transient version of `shrink-window-horizontally"
    (interactive)
    (let ((echo-keystrokes nil))
      (shrink-window-horizontally 1)
      (message "Resize: [{] Shrink-h, [}] Enlarge-h, [&] Shrink-v, [^] Enlarge-v")
      (set-transient-map
       (let ((map (make-sparse-keymap)))
         (define-key map [?{] #'shrink-window-horizontally)
         (define-key map [?}] #'enlarge-window-horizontally)
         (define-key map [?&] #'shrink-window)
         (define-key map [?^] #'enlarge-window)
         map)
       t)))

  (defun transient-shrink-window ()
    "Transient version of `shrink-window"
    (interactive)
    (let ((echo-keystrokes nil))
      (shrink-window 1)
      (message "Resize: [{] Shrink-h, [}] Enlarge-h, [&] Shrink-v, [^] Enlarge-v")
      (set-transient-map
       (let ((map (make-sparse-keymap)))
         (define-key map [?{] #'shrink-window-horizontally)
         (define-key map [?}] #'enlarge-window-horizontally)
         (define-key map [?&] #'shrink-window)
         (define-key map [?^] #'enlarge-window)
         map)
       t)))

  (defun transient-enlarge-window ()
    "Transient version of `enlarge-window"
    (interactive)
    (let ((echo-keystrokes nil))
      (enlarge-window 1)
      (message "Resize: [{] Shrink-h, [}] Enlarge-h, [&] Shrink-v, [^] Enlarge-v")
      (set-transient-map
       (let ((map (make-sparse-keymap)))
         (define-key map [?{] #'shrink-window-horizontally)
         (define-key map [?}] #'enlarge-window-horizontally)
         (define-key map [?&] #'shrink-window)
         (define-key map [?^] #'enlarge-window)
         map)
       t)))

  (global-set-key [remap enlarge-window-horizontally]
                  'transient-enlarge-window-horizontally)
  (global-set-key [remap shrink-window-horizontally]
                  'transient-shrink-window-horizontally)
  (global-set-key [remap enlarge-window]
                  'transient-enlarge-window)
  (global-set-key [remap shrink-window]
                  'transient-shrink-window)
#+end_src
* Look and feel
*This part should not be changed frequently. Spend time on important things*
** Fonts
 Set default font, the font size configuration is moved to ~local-variables.el~
#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (dolist (font '("Symbol" "Apple Color Emoji" "Segoe UI Symbol" "Symbola"))
      (set-fontset-font t 'unicode font nil 'prepend))
    (dolist (charset '(kana han cjk-misc bopomofo))
      (set-fontset-font t charset
                        (font-spec :family "LXGW Bright")))
    (set-frame-font "Sarasa Term SC" nil t))
#+END_SRC
*** prog-mode font

Use separate font for ~prog-mode~
#+BEGIN_SRC emacs-lisp
  (defface cc-font
    '((t :family "Sarasa Term SC"))
    "program fonts"
    :group 'basic-faces)
  (dolist (hook '(prog-mode-hook conf-mode-hook yaml-mode-hook))
    (add-hook hook
              #'(lambda ()
                  (if (display-graphic-p)
                      (progn
                        (set (make-local-variable 'buffer-face-mode-face) 'cc-font)
                        (buffer-face-mode t)
                        ;; (text-scale-increase +1)
                        )))))
#+END_SRC

** Ligature

*** MasOS

#+BEGIN_SRC emacs-lisp :tangle (if (eq system-type 'darwin) "yes" "no")
  (mac-auto-operator-composition-mode +1)
#+END_SRC

*** Linux

#+begin_src emacs-lisp :tangle (if (eq system-type 'gnu/linux) "yes" "no")
  (add-to-list 'load-path
               (concat user-emacs-directory "site-packages/ligature"))
  (require 'ligature)
  (ligature-set-ligatures 't '("www"))
  ;; Enable traditional ligature support in eww-mode, if the
  ;; `variable-pitch' face supports it
  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
  ;; Enable ligature in other documentation mode
  (dolist (mode '(org-mode markdown-mode))
    (ligature-set-ligatures mode '("ff" "fi" "ffi")))
  ;; Enable all ligatures in programming modes
  (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--"
                                       "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>"
                                       "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-"
                                       ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>"
                                       "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<"
                                       "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "///" "_|_"
                                       "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||"
                                       "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<"
                                       "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->"
                                       "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+"
                                       "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".="
                                       ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/="
                                       "/>" "//" "__" "~~" "(*" "*)"
                                       "\\\\" "://"))
  (global-ligature-mode t)
#+end_src

*** pagebreak
#+begin_src emacs-lisp
  (init/ensure-package 'page-break-lines)
  ;; (if (eq system-type 'gnu/linux)
  ;;  (setq-default page-break-lines-char 9596))
  (dolist (hook '(prog-mode-hook conf-mode-hook yaml-mode-hook))
   (add-hook hook 'page-break-lines-mode))
#+end_src
** Smooth scrolling
#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 0)
  (setq scroll-step 1)
  (setq scroll-conservatively 101)
  (setq scroll-up-aggressively 0.01)
  (setq scroll-down-aggressively 0.01)
  (setq auto-window-vscroll nil)
  (setq fast-but-imprecise-scrolling nil)
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
  (setq mouse-wheel-progressive-speed nil)
  ;; Horizontal Scroll
  (setq hscroll-step 1)
  (setq hscroll-margin 0)
#+END_SRC
** Theme
*** Issues
We need to advice the theme changer so that theme can be completely changed in runtime.
#+BEGIN_SRC emacs-lisp
  (defcustom load-theme-before-hook nil
    "Functions to run before load theme."
    :type 'hook)
  (defcustom load-theme-after-hook nil
    "Functions to run after load theme."
    :type 'hook)
  (defun load-theme-hook-wrapper (origin-func theme &rest args)
    "A wrapper of hooks around `load-theme'."
    (mapc #'disable-theme custom-enabled-themes)
    (run-hook-with-args 'load-theme-before-hook theme)
    (apply origin-func theme args)
    (run-hook-with-args 'load-theme-after-hook theme))
  (advice-add 'load-theme :around #'load-theme-hook-wrapper)
#+END_SRC
*** Setup theme

Install themes

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path
               (concat user-emacs-directory "site-packages/lambda-themes"))
  (require 'lambda-themes)
#+END_SRC

Setup theme.

#+BEGIN_SRC emacs-lisp
  (if (and (boundp 'init/theme-dark)
           (bound-and-true-p init/system-dark-modep))
      (load-theme init/theme-dark 1)
    (if (boundp 'init/theme-light)
        (load-theme init/theme-light 1)))
#+END_SRC

*** Tone down fringe

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'fringe nil
                      :foreground (face-foreground 'default)
                      :background (face-background 'default))
#+END_SRC

*** Add fringe indicators
#+begin_src emacs-lisp
  (dolist (hook '(prog-mode-hook
                  text-mode-hook
                  telega-chat-mode-hook
                  wl-summary-mode-hook))
   (add-hook hook
             (lambda ()
               (setq indicate-buffer-boundaries 'right))))
#+end_src
*** Tone down headerline

#+begin_src emacs-lisp
  (set-face-attribute 'header-line nil
                      :background (face-background 'default))
#+end_src

** Dimmer

#+begin_src emacs-lisp :tangle no
  (init/ensure-package 'dimmer)
  (dimmer-configure-posframe)
  (dimmer-mode 1)
#+end_src

** Icon
Set up all-the-icons
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'all-the-icons)
#+END_SRC
I do not manually install the fonts of ~all-the-icons~. System package manager (~pacman~) maintains the font.
** Tabs
*** Sort-tab

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path
               (concat user-emacs-directory "site-packages/sort-tab"))
  (require 'sort-tab)
  (sort-tab-mode +1)
  (global-set-key (kbd "<S-left>") 'sort-tab-select-prev-tab)
  (global-set-key (kbd "<S-right>") 'sort-tab-select-next-tab)
  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "<S-left>") 'sort-tab-select-prev-tab)
    (define-key org-mode-map (kbd "<S-right>") 'sort-tab-select-next-tab))
  (defun sort-tab-refresh (&optional args)
    (interactive)
    (if sort-tab-mode
        (progn (sort-tab-mode -1)
               (sort-tab-mode 1))))

#+END_SRC

**** Override hide behavior
#+BEGIN_SRC emacs-lisp
  (advice-add 'sort-tab-buffer-need-hide-p
              :around #'(lambda (origin buf)
                          (let ((name (buffer-name buf)))
                            (cond
                             ((string-equal name "*eshell*")
                              nil)
                             ((string-equal name "TAGS")
                              t)
                             ((string-suffix-p "syntex.gz" name)
                              t)
                             ((string-prefix-p "*eww" name)
                              nil)
                             (t (apply origin `(,buf)))))))

#+END_SRC


**** Tone down background color
#+begin_src emacs-lisp
  (set-face-attribute 'sort-tab-current-tab-face
                      nil
                      :background (face-background 'mode-line)
                      :foreground (face-foreground 'mode-line))
  ;; (set-face-attribute 'sort-tab-separator-face
  ;;                     nil
  ;;                     :foreground (face-foreground 'mode-line))
  (setq-default sort-tab-separator "⦚")
  #+end_src
*** Save and revert buffer state

#+BEGIN_SRC emacs-lisp
  (defun sort-tab-get-session-and-kill-all-buffers ()
    (let* ((buffer-list (sort-tab-get-buffer-list))
           (session-list (mapcar #'(lambda (buf) (with-current-buffer buf
                                                   (if buffer-file-name
                                                       `("file" ,buffer-file-name ,sort-tab-buffer-freq)
                                                     (cond ((derived-mode-p 'eshell-mode)
                                                            `("eshell" ,(eshell/pwd) ,sort-tab-buffer-freq ,(buffer-name)))
                                                           ((derived-mode-p 'dired-mode)
                                                            `("dired" ,dired-directory ,sort-tab-buffer-freq))
                                                           (t nil)))))
                                 buffer-list)))
      (mapcar #'kill-buffer buffer-list)
      session-list))

  (defun sort-tab-revert-session (session-list)
    (mapcar #'(lambda (pair)
                (let ((mode (car pair))
                      (file (cadr pair))
                      (freq (caddr pair)))
                  (cond ((equal mode "file") (with-current-buffer (find-file file)
                                               (setq-local sort-tab-buffer-freq freq)))
                        ((equal mode "eshell") (let ((default-directory file))
                                                 (with-current-buffer (eshell 17)
                                                   (rename-buffer (cadddr pair))
                                                   (setq-local sort-tab-buffer-freq freq))))
                        ((equal mode "dired") (with-current-buffer (dired file)
                                                (setq-local sort-tab-buffer-freq freq))))))
            session-list)
    (if sort-tab-mode
        (progn (sort-tab-mode -1)
               (sort-tab-mode 1))))

  (defun act/save-session (session-file)
    "Save current session into a session file."
    (interactive
     (list (read-file-name "Session file to save: " "~/.emacs.d/sessions/")))
    (with-temp-file session-file
      (prin1 (sort-tab-get-session-and-kill-all-buffers) (current-buffer)))
    (switch-to-buffer "*scratch*"))

  (defun act/load-session (session-file)
    "Load session from session file, clear current session."
    (interactive
     (list (read-file-name "Session file to load: " "~/.emacs.d/sessions/")))
    (act/save-session "/dev/null")
    (sort-tab-revert-session
     (with-temp-buffer
       (insert-file-contents session-file)
       (cl-assert (eq (point) (point-min)))
       (read (current-buffer)))))

  (defun act/exchange-session (session-file)
    "Exchange session with session from file."
    (interactive
     (list (read-file-name "Session file to interchange: " "~/.emacs.d/sessions/")))
    (let ((session (with-temp-buffer
                     (insert-file-contents session-file)
                     (cl-assert (eq (point) (point-min)))
                     (read (current-buffer)))))
      (sort-tab-save-session session-file)
      (sort-tab-revert-session session)))

  (defun act/kill-session ()
    "Clear current session"
    (interactive)
    (act/save-session "/dev/null"))
#+END_SRC

** Modeline

Use =moody=

#+begin_src emacs-lisp :tangle no
  (init/ensure-package 'moody)
  (setq x-underline-at-descent-line t)
  (moody-replace-mode-line-buffer-identification)
  (moody-replace-vc-mode)
  (moody-replace-eldoc-minibuffer-message-function)
  (display-time-mode 1)
  ;;(moody-replace-element )
  (column-number-mode 1)
  (size-indication-mode 1)
#+end_src

Hide minor-modes

#+begin_src emacs-lisp :tangle no
  (init/ensure-package 'minions)
  (minions-mode +1)
#+end_src

#+begin_src emacs-lisp :tangle no
  (add-to-list 'load-path
               (concat user-emacs-directory "site-packages/awesome-tray"))
  (setq awesome-tray-mode-line-active-color (face-background 'mode-line))
  (setq awesome-tray-mode-line-inactive-color (face-background 'mode-line-inactive))
  (require 'awesome-tray)
  (setq awesome-tray-input-method-en-style "")
  (setq awesome-tray-input-method-zh-style "ㄓ")
  (setq awesome-tray-file-name-max-length 40)
  (setq awesome-tray-git-update-duration 1)
  (setq awesome-tray-active-modules '("location" "belong" "file-path" "buffer-read-only" "git" "mode-name" "input-method"))
  (setq awesome-tray-info-padding-right 1)
  (set-face-attribute 'mode-line nil
                      :foreground (face-background 'mode-line))
  (set-face-attribute 'mode-line-inactive nil
                      :foreground (face-background 'mode-line-inactive))
  (set-face-attribute 'mode-line-buffer-id nil
                      :foreground (face-background 'mode-line))
  (setq-default mode-line-format
                '("%e" mode-line-front-space
                 (:propertize
                  ("" mode-line-mule-info mode-line-client mode-line-modified mode-line-remote)
                  display
                  (min-width
                   (5.0)))))
  (awesome-tray-mode 1)
#+end_src


=doom-modeline=
#+begin_src emacs-lisp
  (init/ensure-package 'doom-modeline)
  (setq doom-modeline-icon nil
        doom-modeline-unicode-fallback nil
        doom-modeline-height 1
        doom-modeline-buffer-modification-icon nil
        doom-modeline-project-detection 'project)
  (display-time-mode +1)
  (column-number-mode +1)
  (if (eq system-type 'darwin)
   (defun my-doom-modeline--font-height ()
     "Calculate the actual char height of the mode-line."
     (+ (frame-char-height) 2))
   (defun my-doom-modeline--font-height ()
     "Calculate the actual char height of the mode-line."
     (+ (/ (* (frame-char-height) 1080) (display-pixel-height)) 2))
   )
  (advice-add #'doom-modeline--font-height :override #'my-doom-modeline--font-height)
  (add-hook 'after-init-hook 'doom-modeline-mode)

#+end_src
** Line number
#+BEGIN_SRC emacs-lisp
  (dolist (hook '(prog-mode-hook conf-mode-hook yaml-mode-hook))
    (add-hook hook 'display-line-numbers-mode))
#+END_SRC

*** Tone down background, modify font
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'line-number-current-line
                      nil
                      :weight 'bold
                      :height (face-attribute 'default :height)
                      ; :background (face-background 'line-number)
                      ; :foreground (face-foreground 'line-number)
                      :family (face-attribute 'cc-font :family))
  (set-face-attribute 'line-number
                      nil
                      :weight 'light
                      :height (face-attribute 'default :height)
                      :background (face-background 'default)
                      :family (face-attribute 'cc-font :family))
#+END_SRC
*** Scaling as text-scaling happens
#+begin_src emacs-lisp
  (defun post-text-scale-callback ()
    ;; fix line number text size
    (let ((new-size (floor (* (face-attribute 'default :height)
                              (expt text-scale-mode-step text-scale-mode-amount)))))
      (set-face-attribute 'line-number nil :height new-size)
      (set-face-attribute 'line-number-current-line nil :height new-size)))

  (add-hook 'text-scale-mode-hook 'post-text-scale-callback)
#+end_src
** Extra features
*** Rich ivy
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'ivy-rich)
  (init/ensure-package 'all-the-icons-ivy-rich)
  (ivy-rich-mode 1)
  (all-the-icons-ivy-rich-mode 1)
  (setq ivy-rich-parse-remote-buffer nil)
#+END_SRC
*** Brackets
**** Look
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'rainbow-delimiters)
  (init/ensure-package 'highlight-parentheses)
#+END_SRC
**** Display
#+BEGIN_SRC emacs-lisp
  (dolist (hook '(prog-mode-hook conf-mode-hook yaml-mode-hook))
   (add-hook hook #'show-paren-mode)
   (add-hook hook #'highlight-parentheses-mode))
#+END_SRC
**** Smart parens
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'smartparens)
  (add-hook 'after-init-hook 'smartparens-global-mode)
  (sp-pair "(" nil :unless '(sp-point-before-word-p))
  (sp-pair "[" nil :unless '(sp-point-before-word-p))
  (sp-pair "{" nil :unless '(sp-point-before-word-p))
  (sp-pair "\"" nil :unless '(sp-point-before-word-p))
  (sp-pair "\'" nil :unless '(sp-point-before-word-p))
  (sp-pair "`" nil :actions :rem)
#+END_SRC
*** Display HEX/RGB color
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'rainbow-mode)
#+END_SRC
* Languages
** Completion system
*** Corfu
Install ~corfu~ and globally enable corfu
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'corfu)
  (init/ensure-package 'cape)
  (init/ensure-package 'yasnippet)
  (yas-reload-all)
  (add-hook 'prog-mode-hook 'yas-minor-mode)
  (global-corfu-mode)
#+END_SRC

Configurations

#+BEGIN_SRC emacs-lisp
  (setq corfu-auto t
        corfu-auto-prefix 1
        corfu-auto-delay 0
        corfu-quit-at-boundary t
        corfu-quit-no-match nil)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-tex)
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-keyword)
  (setq dabbrev-ignored-buffer-regexps
        (rx (or (seq bos (any " *"))
                (seq ".pdf" eos))))
#+END_SRC
**** Enable Corfu in minibuffer
#+BEGIN_SRC emacs-lisp
  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer if `completion-at-point' is bound."
    (when (where-is-internal #'completion-at-point (list (current-local-map)))
      (corfu-mode 1)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer)
#+END_SRC

*** LSP

Install ~lsp-mode~.

#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'lsp-mode)
#+END_SRC

Enable ~which-key~ help in ~lsp mode~.

#+BEGIN_SRC emacs-lisp
  (add-hook 'lsp-mode-hook 'lsp-enable-which-key-integration)
#+END_SRC

We need to set ~idle-delay~ to tell LSP when it can update.

#+BEGIN_SRC emacs-lisp
  (setq lsp-idle-delay 1)
#+END_SRC

Disable some annoying feature

#+BEGIN_SRC emacs-lisp
  (setq lsp-diagnostic-package :none)
  ;; (setq lsp-headerline-breadcrumb-enable nil)
  (setq lsp-headerline-breadcrumb-enable-diagnostics nil)
  (setq lsp-lens-enable nil)
#+END_SRC

Disable default company completion provider

#+BEGIN_SRC emacs-lisp
  (setq lsp-completion-provider :none)
  (defun init/lsp-mode-setup-completion ()
    (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
          '(flex)))
  (add-hook 'lsp-mode-hook #'init/lsp-mode-setup-completion)
#+END_SRC
** Tree-sitter Integration

Tree-sitter is helpful in structual editing and grammar highlighting.
To install tree-sitter

#+begin_src emacs-lisp
  (init/ensure-package-lazy 'tree-sitter)
  (init/ensure-package-lazy 'tree-sitter-langs)
#+end_src

We require =grammatical-edit= to enable structual editing

#+begin_src emacs-lisp
  (add-to-list 'load-path
               (concat user-emacs-directory "site-packages/grammatical-edit"))
  (require 'grammatical-edit)
  (dolist (hook (list
                 'c-mode-common-hook
                 'c-mode-hook
                 'c++-mode-hook
                 'python-mode-hook))
    (add-hook hook #'(lambda ()
                       (tree-sitter-mode 1)
                       (grammatical-edit-mode 1))))

  (define-key grammatical-edit-mode-map (kbd "(") 'grammatical-edit-open-round)
  (define-key grammatical-edit-mode-map (kbd "[") 'grammatical-edit-open-bracket)
  (define-key grammatical-edit-mode-map (kbd "{") 'grammatical-edit-open-curly)
  (define-key grammatical-edit-mode-map (kbd ")") 'grammatical-edit-close-round)
  (define-key grammatical-edit-mode-map (kbd "]") 'grammatical-edit-close-bracket)
  (define-key grammatical-edit-mode-map (kbd "}") 'grammatical-edit-close-curly)
  (define-key grammatical-edit-mode-map (kbd "=") 'grammatical-edit-equal)

  (define-key grammatical-edit-mode-map (kbd "%") 'grammatical-edit-match-paren)
  (define-key grammatical-edit-mode-map (kbd "\"") 'grammatical-edit-double-quote)
  (define-key grammatical-edit-mode-map (kbd "'") 'grammatical-edit-single-quote)

  (define-key grammatical-edit-mode-map (kbd "SPC") 'grammatical-edit-space)
  (define-key grammatical-edit-mode-map (kbd "RET") 'grammatical-edit-newline)

  (define-key grammatical-edit-mode-map (kbd "DEL") 'grammatical-edit-backward-delete)
  (define-key grammatical-edit-mode-map (kbd "C-d") 'grammatical-edit-forward-delete)
  (define-key grammatical-edit-mode-map (kbd "C-k") 'grammatical-edit-kill)

  (define-key grammatical-edit-mode-map (kbd "M-\"") 'grammatical-edit-wrap-double-quote)
  (define-key grammatical-edit-mode-map (kbd "M-'") 'grammatical-edit-wrap-single-quote)
  (define-key grammatical-edit-mode-map (kbd "M-[") 'grammatical-edit-wrap-bracket)
  (define-key grammatical-edit-mode-map (kbd "M-{") 'grammatical-edit-wrap-curly)
  (define-key grammatical-edit-mode-map (kbd "M-(") 'grammatical-edit-wrap-round)
  (define-key grammatical-edit-mode-map (kbd "M-s") 'grammatical-edit-unwrap)

  (define-key grammatical-edit-mode-map (kbd "C-j") 'grammatical-edit-jump-up)
#+end_src
** Verilog
Require built-in ~verilog-mode~.
#+BEGIN_SRC emacs-lisp :tangle no
  (require 'verilog-mode)
#+END_SRC
Build completion system with ~ctags~ and ~company-keywords~.
#+BEGIN_SRC emacs-lisp :tangle no
  (init/ensure-package 'citre)
  (setq verilog-imenu-generic-expression
        '(("*Outputs*" "^\\s-*\\(output\\)\\s-+\\(reg\\|wire\\|logic\\|\\)\\s-+\\(\\|\\[[^]]+\\]\\s-+\\)\\([A-Za-z0-9_]+\\)" 4)
          ("*Inputs*" "^\\s-*\\(input\\)\\s-+\\(reg\\|wire\\|logic\\|\\)\\s-+\\(\\|\\[[^]]+\\]\\s-+\\)\\([A-Za-z0-9_]+\\)" 4)
          (nil "^\\s-*\\(?:m\\(?:odule\\|acromodule\\)\\|p\\(?:rimitive\\|rogram\\|ackage\\)\\)\\s-+\\([a-zA-Z0-9_.:]+\\)" 1)
          ("*Wires*" "^\\s-*\\(wire\\)\\s-+\\(\\|\\[[^]]+\\]\\s-+\\)\\([A-Za-z0-9_]+\\)" 3)
          ("*Regs*" "^\\s-*\\(reg\\)\\s-+\\(\\|\\[[^]]+\\]\\s-+\\)\\([A-Za-z0-9_]+\\)" 3)
          ("*Parameters*" "^\\s-*\\(parameter\\)\\s-+\\([A-Za-z0-9_]+\\)" 2)
          ("*Instances*" "^\\s-*\\(?1:[A-Za-z0-9_]+\\)\\s-+\\1" 1)
          ("*Classes*" "^\\s-*\\(?:\\(?:virtual\\|interface\\)\\s-+\\)?class\\s-+\\([A-Za-z_][A-Za-z0-9_]+\\)" 1)
          ("*Tasks*" "^\\s-*\\(?:\\(?:static\\|pure\\|virtual\\|local\\|protected\\)\\s-+\\)*task\\s-+\\(?:\\(?:static\\|automatic\\)\\s-+\\)?\\([A-Za-z_][A-Za-z0-9_:]+\\)" 1)
          ("*Functions*" "^\\s-*\\(?:\\(?:static\\|pure\\|virtual\\|local\\|protected\\)\\s-+\\)*function\\s-+\\(?:\\(?:static\\|automatic\\)\\s-+\\)?\\(?:\\w+\\s-+\\)?\\(?:\\(?:un\\)signed\\s-+\\)?\\([A-Za-z_][A-Za-z0-9_:]+\\)" 1)
          ("*Interfaces*" "^\\s-*interface\\s-+\\([a-zA-Z_0-9]+\\)" 1)
          ("*Types*" "^\\s-*typedef\\s-+.*\\s-+\\([a-zA-Z_0-9]+\\)\\s-*;" 1)))
  (require 'company-keywords)
  (add-to-list 'company-keywords-alist (cons 'verilog-mode verilog-keywords))
  (defun company-citre (-command &optional -arg &rest _ignored)
    "Completion backend of Citre.  Execute COMMAND with ARG and IGNORED."
    (interactive (list 'interactive))
    (cl-case -command
      (interactive (company-begin-backend 'company-citre))
      (prefix (and (bound-and-true-p citre-mode)
                   (or (citre-get-symbol) 'stop)))
      (meta (citre-get-property 'signature -arg))
      (annotation (citre-capf--get-annotation -arg))
      (candidates (all-completions -arg (citre-capf--get-collection -arg)))
      (ignore-case (not citre-completion-case-sensitive))))

  (defun init/regenerate-tags ()
    (interactive)
    (if (and (boundp 'projectile-project-root)
             (projectile-project-root))
        (citre-update-this-tags-file t)
      ))
  (add-hook 'verilog-mode-hook (lambda ()
                                 (citre-auto-enable-citre-mode)
                                 (make-local-variable 'company-backends)
                                 (setq company-backends '((company-keywords
                                                           company-citre
                                                           )))
                                 (company-mode)
                                 ;; (make-local-variable 'after-save-hook)
                                 ;; (add-hook 'after-save-hook 'citre-update-this-tags-file)
                                 ))
  (add-to-list 'company-transformers #'delete-dups)
#+END_SRC
** Python
*** Conda
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'conda)
#+END_SRC
Setup conda
#+BEGIN_SRC emacs-lisp
  (conda-env-initialize-eshell)
  (conda-env-activate 'base)
#+END_SRC
*** Pyright
~yapf~ and ~pyright~ are used to format and complete.
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'lsp-pyright)
  (defun lsp-pyright-format-buffer ()
    (interactive)
    (when (and (executable-find "yapf") buffer-file-name)
      (call-process "yapf" nil nil nil "-i" buffer-file-name "--style={COLUMN_LIMIT=256}")
      (revert-buffer t t)))
  (add-hook 'python-mode-hook
            #'(lambda ()
                (lsp)
                (add-hook 'after-save-hook #'lsp-pyright-format-buffer t t)))
  (when (executable-find "python3")
    (setq lsp-pyright-python-executable-cmd "python3"))
#+END_SRC
** C/C++
Installing ~ccls~ if ccls exists.
#+BEGIN_SRC emacs-lisp :tangle (if (executable-find "ccls") "yes" "no")
  (init/ensure-package-lazy 'ccls)
  (setq ccls-sem-highlight-method nil)
#+END_SRC
Add lsp to cc-mode hook
#+BEGIN_SRC emacs-lisp
  (dolist (hook '(c-mode-hook c++-mode-hook))
    (add-hook hook #'lsp))
#+END_SRC
** Rust
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'rust-mode)
  (setq lsp-rust-server 'rust-analyzer)
  (setq lsp-rust-analyzer-cargo-watch-enable nil)
  (cl-defmethod lsp-clients-extract-signature-on-hover (contents (_server-id (eql rust-analyzer)))
    (-let* (((&hash "value") contents)
            (groups (--partition-by (s-blank? it) (s-lines (s-trim value))))
            (sig_group (if (s-equals? "```rust" (car (-third-item groups)))
                           (-third-item groups)
                         (car groups)))
            (sig (--> sig_group
                      (--drop-while (s-equals? "```rust" it) it)
                      (--take-while (not (s-equals? "```" it)) it)
                      (s-join "" it))))
      (lsp--render-element (concat "```rust\n" sig "\n```"))))

  (add-hook 'rust-mode-hook #'(lambda ()
                                (setq-local compile-command "cargo build")
                                (lsp)))
#+END_SRC
** Emacs-Lisp
Use =paredit= in =elisp-mode=.  Configure =smartparen= mode.
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'paredit)
  (setq backward-delete-char-untabify-method 'all)
  (add-hook 'scheme-mode-hook 'paredit-mode)
  (add-hook 'scheme-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
  (add-hook 'emacs-lisp-mode 'rainbow-delimiters-mode)
  (dolist (mode '(emacs-lisp-mode elisp-mode))
    (sp-local-pair mode "'" nil :actions nil))
#+END_SRC
** Shell
Install ~fish-mode~ and config keybindings
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'fish-mode)
#+END_SRC
** Matlab
Install ~matlab-mode~
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'matlab-mode)
#+END_SRC
** YAML
Install ~yaml-mode~
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'yaml-mode)
#+END_SRC
* Documentation
** Spell Check

#+begin_src emacs-lisp
  (setq ispell-dictionary "en_US"
        ispell-program-name "hunspell"
        ispell-personal-dictionary (expand-file-name "hunspell_dict.txt" user-emacs-directory))
#+end_src
** Emacs Rime
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'rime)
  (with-eval-after-load 'rime
    (add-hook 'kill-emacs-hook #'rime-lib-finalize) ;; avoid crash on exit
    (set-face-attribute 'rime-highlight-candidate-face nil :weight 'bold)
    (define-key rime-mode-map [escape] #'rime-inline-ascii)
    (advice-add 'rime-inline-ascii :after
                #'(lambda ()
                    (interactive)
                    (if (rime--ascii-mode-p)
                        (message "%s"
                                 (concat "rime inline ascii "
                                         (propertize "enabled" 'face '(:foreground "green"))))
                      (message "%s"
                               (concat "rime inline ascii "
                                       (propertize "disabled" 'face '(:foreground "red"))))))))
  (setq default-input-method "rime")
  (setq rime-show-candidate 'posframe
        rime-librime-root (concat user-emacs-directory "librime/dist/")
        rime-user-data-dir (concat user-emacs-directory "rime/")
        rime-translate-keybindings
        '("C-f" "C-b" "C-n" "C-p" "C-g" "C-`")
        rime-show-preedit 'inline
        rime-disable-predicates
        '(
          rime-predicate-prog-in-code-p
          rime-predicate-org-in-src-block-p
          rime-predicate-current-uppercase-letter-p
          rime-predicate-after-alphabet-char-p
          rime-predicate-after-ascii-char-p
          rime-predicate-evil-mode-p
          rime-predicate-hydra-p
          rime-predicate-punctuation-line-begin-p
          rime-predicate-space-after-cc-p
          rime-predicate-tex-math-or-command-p
          ))
  (setq rime-posframe-properties
        (list :font "LXGW WenKai"
              ;; :background (face-background 'mode-line)
              :internal-border-width 1))
#+END_SRC

** Org mode

*** Define seperate font for org mode

The hook for =buffer-face-mode= is moved to session [[*Beautify]] since the
sequence of mode loading should be well taken care of.

#+BEGIN_SRC emacs-lisp
  (defface lt-font
    '((t :family "Bookerly"))
    "Font for literature"
    :group 'basic-faces)
  (set-face-attribute 'variable-pitch nil
                      :family (face-attribute 'lt-font :family))
  (variable-pitch-mode 1)
  (defun buffer-toggle-highlight-foreground (&optional args)
    (interactive)
    (if (and (boundp 'face-remap-add-relative-cookie) face-remap-add-relative-cookie)
        (progn (face-remap-remove-relative face-remap-add-relative-cookie)
               (setq face-remap-add-relative-cookie nil))
      (set (make-local-variable 'face-remap-add-relative-cookie) (face-remap-add-relative 'default '(:foreground "#000000")))))
#+END_SRC

*** Disable Large Titles

#+begin_src emacs-lisp
  (setq org-level-color-stars-only t)
#+end_src

***  Table Align

#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'valign)
  ; valign mode should be enabled as file local variable
  ;; (if (display-graphic-p)
  ;;     (add-hook 'org-mode-hook #'valign-mode))
#+END_SRC

*** Org Download

#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'org-download)
  (add-hook 'org-mode-hook 'org-download-enable)
  (with-eval-after-load 'org
   (define-key org-mode-map (kbd "C-c C-v") 'org-download-clipboard))
#+END_SRC

*** Org Bars

The hook for =org-bars= is moved to session [[*Beautify]] since the
sequence of mode loading should be well taken care of.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path
               (concat user-emacs-directory "site-packages/org-bars"))
  (require 'org-bars)
  (add-hook 'org-mode-hook 'org-indent-mode)
  (add-hook 'org-mode-hook 'org-bars-mode)
#+END_SRC

*** Quick jump to specific headline via ivy and fuzzy search

It will be helpful to jump quickly when editing ~conf.org~. Also see
[[https://github.com/abo-abo/swiper/issues/986][discussion]].

#+BEGIN_SRC emacs-lisp
  (setq org-goto-interface 'outline-path-completion)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

I use ~"C-j"~ to invoke jump.

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-j") 'org-goto))
#+END_SRC


*** Latex Editing

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'org
    ;; Linux cannot handle latex fragment properly
    (if (eq system-type 'gnu/linux)
        (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0)))
    (setq org-preview-latex-default-process 'dvisvgm
          org-image-actual-width 600)
    (require 'latex))

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((latex . t)))

  (if (eq system-type 'gnu/linux)
   (setq org-latex-create-formula-image-program 'imagemagick))
  (setq org-highlight-latex-and-related '(latex))

  (defun wrap-region-with-added (&optional args)
    "wrap `region' with [[changes:added][`region']]"
    (interactive)
    (when (region-active-p)
      (let ((BEG (region-beginning))
            (END (region-end)))
        (setq mark-active nil)
        (goto-char END)
        (insert "]]")
        (goto-char BEG)
        (insert "[[changes:added]["))))
#+END_SRC


*** Word Wrap

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook #'auto-fill-mode)
#+END_SRC

*** Local Functions

#+BEGIN_SRC emacs-lisp
  (defun org-copy-src-block-link()
    (interactive)
    (save-excursion
      (forward-line -1)
      (org-edit-src-code)
      (clipboard-kill-ring-save (point-min) (point-max))
      (org-edit-src-exit)))
#+END_SRC

*** Beautify

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'org
    ;; Make verbatim with highlight text background.
    (add-to-list 'org-emphasis-alist
                 `("=" (:background ,(face-background 'org-block)
                                    :family ,(face-attribute 'cc-font :family))))
    ;; Make deletion(obsolote) text foreground with dark gray.
    (add-to-list 'org-emphasis-alist
                 '("+" (:foreground "dark gray"
                                    :strike-through t)))
    ;; Make code style around with box.
    (add-to-list 'org-emphasis-alist
                 '("~" (:box (:line-width 1
                                          :color "grey75"
                                          :style released-button))))
    (setq org-hide-emphasis-markers t
          org-pretty-entities t))

  (with-eval-after-load 'whitespace
    (dolist (face '(whitespace-space whitespace-tab whitespace-newline))
      (set-face-attribute face nil
                          :background (face-background 'default)
                          :foreground "grey75")))
  (setq whitespace-style '(face spaces tabs newline space-mark tab-mark newline-mark))
  (add-hook 'org-mode-hook (lambda ()
                             (if (display-graphic-p)
                                 (progn
                                   (set (make-local-variable 'buffer-face-mode-face)
                                        'lt-font)
                                   (buffer-face-mode t)
                                   (face-remap-add-relative 'org-block `(:family ,(face-attribute 'cc-font :family)))))
                             (org-bars-mode +1)
                             ;; (text-scale-increase +1)
                             (org-bars-indent)))
  (setq org-ellipsis "  ⇲")
#+END_SRC

*** Completion

Disable completion backends other than =company-files=. Turn on yasnippet mode.

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (require 'org-tempo))
  (add-hook 'org-mode-hook
            (lambda ()
              (setq-local completion-at-point-functions
                          (list #'cape-file))
              (setq-local yas-indent-line 'fixed)
              (yas-minor-mode 1)))
#+end_src

*** Export

Define export processes

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook (lambda ()
                             (setq-local compile-command
                                         (concat "pandoc --pdf-engine=xelatex --toc -V mainfont=\'LXGW Bright\' -o "
                                                 (concat (file-name-sans-extension (buffer-name)) ".pdf ")
                                                 (buffer-name)))))
  (setq org-latex-pdf-process
        '("xelatex -interaction=nonstopmode %f"
          "xelatex -interaction=nonstopmode %f"))
  (with-eval-after-load 'org
    (setq org-latex-default-packages-alist
          (remove '("AUTO" "inputenc" t)
                  org-latex-default-packages-alist)))
#+end_src

*** Babel

#+begin_src emacs-lisp
  (org-babel-do-load-languages 'org-babel-load-languages
                               '((shell . t)
                                 (python . t)))
#+end_src

** Latex

#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'auctex)
  (setq TeX-auto-save t
        TeX-parse-self t
        TeX-source-correlate-mode t
        TeX-source-correlate-start-server t
        TeX-source-correlate-method '((dvi . source-specials)
                                      (pdf . synctex)))
  (setq-default TeX-master nil)
  (init/ensure-package 'lsp-latex)
  (with-eval-after-load 'latex
    (add-to-list
     'TeX-command-list
     '("XeLaTeX" "%`xelatex%(mode)%' %t" TeX-run-TeX nil t))
    (add-to-list
     'TeX-command-list
     '("Make" "make" TeX-run-compile nil t)))
  (dolist
      (hook '(TeX-mode-hook LaTeX-mode-hook bibtex-mode-hook))
    (add-hook hook #'(lambda ()
                       (yas-minor-mode)
                       (lsp))))
  (add-hook 'TeX-mode-hook 'auto-fill-mode)
  (add-hook 'LaTeX-mode-hook 'auto-fill-mode)
#+END_SRC

***  External pdf viewer

=EAF= may be broken when the output file is being compiled.

#+begin_src emacs-lisp
  (setq TeX-source-correlate-mode t)
  (setq TeX-source-correlate-start-server t)
  (setq TeX-view-program-selection
        (quote
         ((output-pdf "Okular"))))
#+end_src
* Extra features
** Set up magit
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'magit)
#+END_SRC
** Eshell
*** Prompt
#+BEGIN_SRC emacs-lisp
  (defun hex-to-hsl (hex)
    "Convert hex string to hsl digits, the result is returned as list"
    (eval `(color-rgb-to-hsl ,@(mapcar
                                (lambda (x)
                                  (/ (float
                                      (string-to-number
                                       (substring hex (car x) (cadr x)) 16)) 256))
                                '((1 3) (3 5) (5 7))))))


  (defun make-color-lighter (hex factor)
    "Make hex color lighter, return string"
    (let ((hsl (hex-to-hsl hex)))
      (eval `(color-rgb-to-hex
              ,@(color-hsl-to-rgb (car hsl)
                                  (min (* (cadr hsl) factor) 1)
                                  (min (* (caddr hsl) factor) 1))
              2))))

  (defun shortened-path (path max-len)
    "Return a modified version of `path', replacing some components
        with single characters starting from the left to try and
        get the path down to `max-len'"
    (let* ((components (split-string (abbreviate-file-name path) "/"))
           (len (+ (1- (length components))
                   (cl-reduce '+ components :key 'length)))
           (str ""))
      (while (and (> len max-len)
                  (cdr components))
        (setq str (concat str (if (= 0 (length (car components)))
                                  "/"
                                (string (elt (car components) 0) ?/)))
              len (- len (1- (length (car components))))
              components (cdr components)))
      (concat str (cl-reduce (lambda (a b) (concat a "/" b)) components))))


  (setq eshell-prompt-function-light
          #'(lambda nil
              (concat
               (propertize "╭─"
                           'face `(:background (face-background 'default) :weight bold))
               (propertize (user-login-name)
                           'face `(:foreground ,(face-foreground 'font-lock-keyword-face) :weight bold))
               (propertize " at "
                           'face `(:background (face-background 'default)))
               (propertize (system-name)
                           'face `(:foreground  ,(face-foreground 'font-lock-builtin-face) :weight bold))
               (propertize " in "
                           'face `(:background (face-background 'default)))
               (propertize (shortened-path (eshell/pwd) 40)
                           'face `(:foreground ,(face-foreground 'font-lock-string-face) :weight bold :slant italic))
               (if (and (boundp 'url-proxy-services)
                        (assoc "http" url-proxy-services))
                   (concat
                    (propertize " via "
                                'face `(:background (face-background 'default)))
                    (propertize (cdr (assoc "http" url-proxy-services))
                                'face `(:foreground ,(face-foreground 'font-lock-doc-face) :weight bold))))
               (propertize "\n"
                           'face `(:background (face-background 'default)))
               (propertize "╰─["
                           'face `(:background (face-background 'default) :weight bold))
               (propertize (if (= (user-uid) 0) "# " "λ")
                           'face `(:slant default :weight bold :foreground ,(face-foreground 'font-lock-constant-face)))
               (propertize "]"
                           'face `(:background (face-background 'default) :weight bold))
               (propertize " "
                           'face `(:background (face-background 'default))))))

  (setq eshell-prompt-regexp "^╰─\\\[[#λ]\\\] ")
  (if (bound-and-true-p init/system-dark-modep)
      (setq eshell-prompt-function
            eshell-prompt-function-dark)
    (setq eshell-prompt-function
          eshell-prompt-function-light))
#+END_SRC
This is just for ~shell~ command
#+BEGIN_SRC emacs-lisp
  (setq comint-prompt-read-only t)
#+END_SRC
*** Syntax highlight
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'eshell-syntax-highlighting)
  (with-eval-after-load 'eshell
    (require 'eshell-syntax-highlighting)
    (set-face-attribute 'eshell-syntax-highlighting-alias-face
                        nil :weight 'bold)
    (set-face-attribute 'eshell-syntax-highlighting-shell-command-face
                        nil :weight 'bold)
    (unless (bound-and-true-p init/system-dark-modep)
      (progn (set-face-foreground 'eshell-syntax-highlighting-alias-face "#2E67D3")
             (set-face-foreground 'eshell-syntax-highlighting-shell-command-face "#2E67D3")))
    (add-hook 'eshell-mode-hook 'eshell-syntax-highlighting-mode))
#+END_SRC
*** FZF fuzzy search
#+BEGIN_SRC emacs-lisp
  (setq eshell-history-size 1024)
  (defun init/ivy-eshell-history ()
    (interactive)
    (require 'em-hist)
    (let* ((start-pos (save-excursion (eshell-bol) (point)))
           (end-pos (point))
           (input (buffer-substring-no-properties start-pos end-pos))
           (command (ivy-read "Command: "
                              (delete-dups
                               (when (> (ring-size eshell-history-ring) 0)
                                 (ring-elements eshell-history-ring)))
                              :initial-input input)))
      (setf (buffer-substring start-pos end-pos) command)
      (end-of-line)))
#+END_SRC
*** z-jump
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'eshell-z)
  (with-eval-after-load 'eshell
    (require 'eshell-z))
  ;; (add-hook 'eshell-mode-hook
  ;;           #'(lambda ()
  ;;               (require 'eshell-z)))
#+END_SRC
*** Colorful ~cat~
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'em-unix
    (defun eshell/cat (&rest args)
      "Like cat(1) but with syntax highlighting."
      (unless args (error "Usage: cat FILE ..."))
      (dolist (filename (eshell-flatten-list args))
        (let ((existing-buffer (get-file-buffer filename))
              (buffer (find-file-noselect filename)))
          (eshell-print
           (with-current-buffer buffer
             (if (fboundp 'font-lock-ensure)
                 (font-lock-ensure)
               (with-no-warnings
                 (font-lock-fontify-buffer)))
             (buffer-string)))
          (unless existing-buffer
            (kill-buffer buffer))
          nil))))
#+END_SRC
*** image cat
#+BEGIN_SRC emacs-lisp
  (defun eshell/imgcat (&rest args)
    "Display image files."
    (unless args (error "Usage: imgcat FILE ..."))
    (dolist (img (eshell-flatten-list args))
      (eshell/printnl
       (propertize " " 'display (create-image img)))))
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook
            #'(lambda ()
                (local-set-key (kbd "C-r") #'init/ivy-eshell-history)))
#+END_SRC
*** Alias
#+BEGIN_SRC emacs-lisp
  (defun eshell/emacs (file)
    (find-file file))
  (defun eshell/vim (file)
    (find-file file))
#+END_SRC
*** Act
#+BEGIN_SRC emacs-lisp
  (defun act/eshell ()
    (interactive)
    (let ((buf (eshell 17)))
      (with-current-buffer buf
        (rename-buffer (concat "esh:" (format "%d" (act/eshell-new-index)))))
      (switch-to-buffer buf)))
  (defun act/eshell-new-index ()
    (let* ((index-list (act/eshell-get-index-list))
           (new-buf-index 0)
           (index-arr (make-vector 100 0)))
      (dolist (i index-list)
        (aset index-arr i 1))
      (while (= (aref index-arr new-buf-index) 1)
        (setq new-buf-index (+ new-buf-index 1)))
      new-buf-index))
  (defun act/eshell-get-index-list ()
    (mapcar #'string-to-number
            (mapcar (apply-partially #'replace-regexp-in-string
                                     "esh:"
                                     "")
                    (seq-filter (apply-partially #'string-match-p
                                                 "esh:[0-9]+")
                                (mapcar #'buffer-name
                                        (buffer-list))))))
#+END_SRC
*** Issues
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'em-term
    (push "ghci" eshell-visual-commands)
    (push "ssh" eshell-visual-commands)
    (push "htop" eshell-visual-commands)
    (add-hook 'eshell-mode-hook
              (lambda ()
                (setq-local corfu-auto nil)
                ;; (face-remap-add-relative 'default `(:height
                ;;                                     ,(round (* 1.5 (face-attribute 'default :height)))))
                )))
#+END_SRC
*** Eshell toggle
#+begin_src emacs-lisp
  (init/ensure-package-lazy 'eshell-toggle)
  (global-set-key (kbd "M-e") 'eshell-toggle)
#+end_src
** Shell
#+begin_src emacs-lisp
  (add-hook 'shell-mode-hook (lambda ()
                               (setq-local corfu-auto nil)
                               (compilation-shell-minor-mode +1)))
#+end_src
** Symbol overlay
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'symbol-overlay)
  (global-set-key (kbd "M-i") 'symbol-overlay-put)
  (global-set-key (kbd "M-n") 'symbol-overlay-switch-forward)
  (global-set-key (kbd "M-p") 'symbol-overlay-switch-backward)
  (global-set-key (kbd "M-k") 'symbol-overlay-remove-all)
  (dolist (hook '(prog-mode-hook conf-mode-hook yaml-mode-hook))
   (add-hook hook 'symbol-overlay-mode))
#+END_SRC


** EAF

Install all packages.

#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (add-to-list 'load-path
               (concat user-emacs-directory
                       "site-packages/eaf"))
  (setq eaf-python-command "/usr/bin/python3")
  (require 'eaf)
  (require 'eaf-pdf-viewer)
  ;; (require 'eaf-system-monitor)
  (require 'eaf-image-viewer)
  ;; (require 'eaf-markdown-previewer)
  ;; (require 'eaf-org-previewer)
  ;; (require 'eaf-file-manager)
  (require 'eaf-all-the-icons)
  ;; (require 'eaf-browser)
  (require 'eaf-org)
#+end_src

Configure the package with a more emacs-like keybindings.

#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (eaf-bind-key scroll_to_begin "M-<" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_to_end "M->" eaf-pdf-viewer-keybinding)
#+end_src

*** Configure pdf-viewer

Configure latex preview.

#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (with-eval-after-load 'latex
   (add-to-list 'TeX-view-program-list '("eaf" eaf-pdf-synctex-forward-view))
   (add-to-list 'TeX-view-program-selection '(output-pdf "eaf")))
#+end_src

Change background color.

#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (setq eaf-pdf-dark-mode nil)
  (setq eaf-buffer-background-color (face-background 'default))
#+end_src

Emacs style keybindings
#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (eaf-bind-key scroll_to_begin "M-<" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_to_end "M->" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_up "n" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_down "p" eaf-pdf-viewer-keybinding)
  (eaf-bind-key jump_to_page "j" eaf-pdf-viewer-keybinding)
#+end_src

Use native search method

#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (add-hook 'eaf-mode-hook
            (lambda () (ctrlf-local-mode -1)))
#+end_src

*** Pdf-tools
This package is only used in OS X

#+begin_src emacs-lisp :tangle (if (eq system-type 'darwin) "yes" "no")
  (init/ensure-package-lazy 'pdf-tools)
  (pdf-loader-install)
  (setq pdf-view-use-scaling t)
  ;; Use pdf-tools to open PDF files
  (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
        TeX-source-correlate-start-server t)
  ;; Update PDF buffers after successful LaTeX runs
  (add-hook 'TeX-after-compilation-finished-functions
            #'TeX-revert-document-buffer)
  (add-hook 'pdf-view-mode #'(lambda ()
                               (ctrlf-local-mode -1)))
#+end_src

Restore session

#+begin_src emacs-lisp :tangle (if (eq system-type 'darwin) "yes" "no")
  ;; workaround for pdf-tools not reopening to last-viewed page of the pdf:
  ;; https://github.com/politza/pdf-tools/issues/18#issuecomment-269515117
  (defun brds/pdf-set-last-viewed-bookmark ()
    (interactive)
    (when (eq major-mode 'pdf-view-mode)
      (bookmark-set (brds/pdf-generate-bookmark-name))))

  (defun brds/pdf-jump-last-viewed-bookmark ()
    (bookmark-set "fake") ; this is new
    (when
        (brds/pdf-has-last-viewed-bookmark)
      (bookmark-jump (brds/pdf-generate-bookmark-name))))

  (defun brds/pdf-has-last-viewed-bookmark ()
    (assoc
     (brds/pdf-generate-bookmark-name) bookmark-alist))

  (defun brds/pdf-generate-bookmark-name ()
    (concat "PDF-LAST-VIEWED: " (buffer-file-name)))

  (defun brds/pdf-set-all-last-viewed-bookmarks ()
    (dolist (buf (buffer-list))
      (with-current-buffer buf
        (brds/pdf-set-last-viewed-bookmark))))

  (add-hook 'kill-buffer-hook 'brds/pdf-set-last-viewed-bookmark)
  (add-hook 'pdf-view-mode-hook 'brds/pdf-jump-last-viewed-bookmark)
  (unless noninteractive  ; as `save-place-mode' does
    (add-hook 'kill-emacs-hook #'brds/pdf-set-all-last-viewed-bookmarks))
#+end_src

*** Configure Browser
#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (if (bound-and-true-p init/local-proxies)
      (let ((http_proxy (cdr (assoc "http" init/local-proxies))))
        (if http_proxy
         (progn
           (setq eaf-proxy-type "http")
           (setq eaf-proxy-host (car (split-string http_proxy ":")))
           (setq eaf-proxy-port (cadr (split-string http_proxy ":")))))))
#+end_src

*** Configure previewer
#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (defun preview-current-buffer (&optional args)
    (interactive)
    (eaf-open (buffer-file-name (current-buffer))))
#+end_src

*** Integration with org-mode

#+begin_src emacs-lisp :tangle (if (bound-and-true-p init/enable-eaf) "yes" "no")
  (defun eaf-org-open-file (file &optional link)
    "An wrapper function on `eaf-open'."
    (eaf-open file))

  ;; use `emacs-application-framework' to open PDF file: link
  (with-eval-after-load 'org
    (add-to-list 'org-file-apps '("\\.pdf\\'" . eaf-org-open-file))
    (add-to-list 'org-file-apps '("\\.jpeg\\'" . eaf-org-open-file))
    (add-to-list 'org-file-apps '("\\.jpg\\'" . eaf-org-open-file))
    (add-to-list 'org-file-apps '("\\.png\\'" . eaf-org-open-file)))
#+end_src
** lua-mode
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'lua-mode)
#+END_SRC
** scala-mode
#+BEGIN_SRC emacs-lisp
  (init/ensure-package 'scala-mode)
#+END_SRC
** ebib

#+BEGIN_SRC emacs-lisp :tangle (if (and (boundp 'init/ebib-file-search-dirs) (boundp 'init/ebib-preload-bib-files)) "yes" "no")
  (init/ensure-package-lazy 'ebib)
  (setq ebib-file-search-dirs init/ebib-file-search-dirs)
  (setq ebib-preload-bib-files init/ebib-preload-bib-files)
  (setq ebib-index-columns '(("Entry Key" 20 t)
                             ("Title" 60 t)
                             ("Author/Editor" 40 t)
                             ("Year" 6 t)))
  (setq ebib-index-column-separator "  ")
  (with-eval-after-load 'ebib
    (require 'org-ebib)
    (setq ebib-file-associations nil)
    (if (not (bound-and-true-p init/enable-eaf))
        (cl-case system-type
          ('gnu/linux (setq ebib-file-associations '(("pdf" . "okular"))))
          ;; ('darwin (setq ebib-file-associations '(("pdf" . "open"))))
          (otherwise t)))
    )
    ;; (setq ebib-file-associations '(("pdf" . "okular")))
    (global-set-key (kbd "C-c e i") 'ebib-insert-citation)
#+END_SRC
** Org Roam
#+BEGIN_SRC emacs-lisp :tangle (if (boundp 'init/org-roam-directory) "yes" "no")
  (init/ensure-package-lazy 'org-roam)
  (setq org-roam-directory init/org-roam-directory)
  (defun org-roam-node-find (&optional args)
    "Lazy load wrapper for org-roam"
    (interactive)
    (require 'org-roam)
    (org-roam-setup)
    (org-roam-node-find))
  (defun org-roam-node-insert (&optional args)
    "Lazy load wrapper for org-roam"
    (interactive)
    (require 'org-roam)
    (org-roam-setup)
    (org-roam-node-insert))
  (defun org-roam-node-list (&optional args)
    "Lazy load wrapper for org-roam"
    (interactive)
    (require 'org-roam)
    (org-roam-setup)
    (org-roam-node-list))
  (global-set-key (kbd "C-c n f") #'org-roam-node-find)
  (global-set-key (kbd "C-c n i") #'org-roam-node-insert)
  (global-set-key (kbd "C-c n l") #'org-roam-buffer-list)
#+END_SRC
*** Advice sort-tab
#+BEGIN_SRC emacs-lisp
  (advice-add 'sort-tab-get-tab-name
              :around #'(lambda (origin buf current-buffer)
                          (let* ((name (buffer-name buf))
                                 (short-name (and name
                                                  (replace-regexp-in-string "20[0-9][0-9][01][0-9][0-3][0-9]+-"
                                                                            "" name))))
                            (if (eq (length name) (length short-name))
                                (apply origin `(,buf ,current-buffer))
                              (let ((short-name-formatted (concat "roam:"
                                                                  (string-remove-suffix ".org" short-name))))
                                (propertize
                                 (format " %s "
                                         (let ((ellipsis "..."))
                                           (if (> (length short-name-formatted) sort-tab-name-max-length)
                                               (format "%s%s"
                                                       (substring short-name-formatted
                                                                  0
                                                                  (- sort-tab-name-max-length (length ellipsis)))
                                                       ellipsis)
                                             short-name-formatted)))
                                 'face
                                 (if (eq buf current-buffer)
                                     'sort-tab-current-tab-face
                                   'sort-tab-other-tab-face)))))))
#+END_SRC
** Org Drill
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'org-drill)
  (defun org-find-drill-file ()
    (interactive)
    (find-file init/org-drill-file))
#+END_SRC
** English Helper
#+BEGIN_SRC emacs-lisp :tangle no
  (add-to-list 'load-path
               (concat user-emacs-directory "site-packages/company-english-helper"))
  (defvaralias 'company-candidates 'corfu--candidates)
  (defalias 'company-mode 'corfu-mode) ;; should be deleted
  (defvaralias 'company-mode 'corfu-mode) ;; should be deleted
  (setq company-backends '())
  (setq completion-at-point-functions-backup completion-at-point-functions)
  (provide 'company)

  (defun set-completion-functions ()
    (setq completion-at-point-functions
          (cl-concatenate 'list (mapcar #'cape-company-to-capf company-backends) completion-at-point-functions-backup)))

  (defun company-grab-symbol ()
    "If point is at the end of a symbol, return it.
      Otherwise, if point is not inside a symbol, return an empty string."
    (if (looking-at "\\_>")
        (buffer-substring (point) (save-excursion (skip-syntax-backward "w_")
                                                  (point)))
      (unless (and (char-after) (memq (char-syntax (char-after)) '(?w ?_)))
        "")))
  (advice-add 'toggle-company-english-helper :after #'set-completion-functions)
  (defun toggle-company-english-helper (&optional args)
    "Lazy load wrapper for english helper"
    (interactive)
    (set-completion-functions)
    (require 'company-english-helper)
    (toggle-company-english-helper))
#+END_SRC

#+begin_src emacs-lisp
  (add-to-list 'load-path
               (concat user-emacs-directory "site-packages/corfu-english-helper"))
  (defun toggle-corfu-english-helper (&optional args)
      "Lazy load wrapper for english helper"
      (interactive)
      (require 'corfu-english-helper)
      (toggle-corfu-english-helper))
#+end_src
** Ripgrep
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'rg)
  (defun rg (&optional args)
    "Lazy load wrapper for rg"
    (interactive)
    (require 'rg)
    (call-interactively 'rg))
#+END_SRC
** IBuffer
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'all-the-icons-ibuffer)
  (init/ensure-package-lazy 'ibuffer-project)
  (setq-default ibuffer-project-use-cache t)
  (global-set-key (kbd "C-x C-b") #'ibuffer)
  (add-hook 'ibuffer-hook
            (lambda ()
              (all-the-icons-ibuffer-mode)
              (setq ibuffer-filter-groups (ibuffer-project-generate-filter-groups))
              (unless (eq ibuffer-sorting-mode 'alphabetic)
                (ibuffer-do-sort-by-alphabetic))))
  (with-eval-after-load 'ibuffer
    (require 'all-the-icons-ibuffer)
    (require 'ibuffer-project))
#+END_SRC
** Dired
#+BEGIN_SRC emacs-lisp
  (init/ensure-package-lazy 'fd-dired)
  (init/ensure-package-lazy 'all-the-icons-dired)
  (with-eval-after-load 'dired
    (require 'dired-x)
    (require 'all-the-icons-dired))
  (when (string= system-type "darwin")
    (setq dired-use-ls-dired nil))
  (setq dired-omit-files "^\\\.")
  (add-hook 'dired-mode-hook #'all-the-icons-dired-mode)
  (add-hook 'dired-mode-hook #'dired-omit-mode)
  (define-key dired-mode-map (kbd "C-c t") #'dired-omit-mode)
  (setq-default dired-listing-switches "-alh")
  ;; (define-key dired-mode-map [remap dired-find-file] #'dired-find-alternate-file)
#+END_SRC

#+begin_src emacs-lisp
  (defun dired-insert-kill-current-dir (DIRNAME)
    (interactive
     (list (dired-get-filename)))
    (call-interactively 'dired-prev-subdir)
    (dired-kill-subdir)
    (dired-insert-subdir DIRNAME))
  (define-key dired-mode-map (kbd "I") 'dired-insert-kill-current-dir)
#+end_src

#+begin_src emacs-lisp
  (defun xah-open-in-external-app (&optional @fname)
    "Open the current file or dired marked files in external app.
  When called in emacs lisp, if @fname is given, open that.
  URL `http://xahlee.info/emacs/emacs/emacs_dired_open_file_in_ext_apps.html'
  Version 2019-11-04 2021-02-16"
    (interactive)
    (let* (
           ($file-list
            (if @fname
                (progn (list @fname))
              (if (string-equal major-mode "dired-mode")
                  (dired-get-marked-files)
                (list (buffer-file-name)))))
           ($do-it-p (if (<= (length $file-list) 5)
                         t
                       (y-or-n-p "Open more than 5 files? "))))
      (when $do-it-p
        (cond
         ((string-equal system-type "windows-nt")
          (mapc
           (lambda ($fpath)
             (shell-command (concat "PowerShell -Command \"Invoke-Item -LiteralPath\" " "'" (shell-quote-argument (expand-file-name $fpath )) "'")))
           $file-list))
         ((string-equal system-type "darwin")
          (mapc
           (lambda ($fpath)
             (shell-command
              (concat "open " (shell-quote-argument $fpath))))  $file-list))
         ((string-equal system-type "gnu/linux")
          (mapc
           (lambda ($fpath) (let ((process-connection-type nil))
                              (start-process "" nil "xdg-open" $fpath))) $file-list))))))

  (defun xah-show-in-desktop ()
    "Show current file in desktop.
   (Mac Finder, File Explorer, Linux file manager)
  This command can be called when in a file buffer or in `dired'.
  URL `http://xahlee.info/emacs/emacs/emacs_dired_open_file_in_ext_apps.html'
  Version 2020-11-20 2021-01-18"
    (interactive)
    (let (($path (if (buffer-file-name) (buffer-file-name) default-directory)))
      (cond
       ((string-equal system-type "windows-nt")
        (shell-command (format "PowerShell -Command Start-Process Explorer -FilePath %s" (shell-quote-argument default-directory)))
        ;; todo. need to make window highlight the file
        )
       ((string-equal system-type "darwin")
        (if (eq major-mode 'dired-mode)
            (let (($files (dired-get-marked-files )))
              (if (eq (length $files) 0)
                  (shell-command (concat "open " (shell-quote-argument (expand-file-name default-directory ))))
                (shell-command (concat "open -R " (shell-quote-argument (car (dired-get-marked-files )))))))
          (shell-command
           (concat "open -R " (shell-quote-argument $path)))))

       ((string-equal system-type "gnu/linux")
        (let (
              (process-connection-type nil)
              (openFileProgram (if (file-exists-p "/usr/bin/gvfs-open")
                                   "/usr/bin/gvfs-open"
                                 "/usr/bin/xdg-open")))
          (start-process "" nil openFileProgram (shell-quote-argument $path)))
        ;; (shell-command "xdg-open .") ;; 2013-02-10 this sometimes froze emacs till the folder is closed. eg with nautilus
        ))))


  (define-key dired-mode-map [remap browse-url-of-dired-file] 'xah-open-in-external-app)
  (define-key dired-mode-map (kbd "C-^") 'xah-show-in-desktop)
#+end_src
** Word Count
#+BEGIN_SRC emacs-lisp
  (defvar words-count-rule-chinese "\\cc"
    "A regexp string to match Chinese characters.")

  (defvar words-count-rule-nonespace "[^[:space:]]"
    "A regexp string to match none pace characters.")

  (defvar words-count-rule-ansci "[A-Za-z0-9][A-Za-z0-9[:punct:]]*"
    "A regexp string to match none pace characters.")

  (defvar words-count-regexp-list
    (list words-count-rule-chinese
          words-count-rule-nonespace
          words-count-rule-ansci)
    "A list for the regexp used in `advance-words-count'.")

  (defvar words-count-message-func 'message--words-count
    "The function used to format message in `advance-words-count'.")

  (defun special--words-count (start end regexp)
    "Count the word from START to END with REGEXP."
    (let ((count 0))
      (save-excursion
        (save-restriction
          (goto-char start)
          (while (and (< (point) end) (re-search-forward regexp end t))
            (setq count (1+ count)))))
      count))
  (defun message--words-count (list start end)
    "Display the word count message.
  Using the LIST passed form `advance-words-count'. START & END are
  required to call extra functions, see `count-lines' &
  `count-words'. When ARG is specified, display a verbose buffer."
    (message
     (format
      "
  -----------~*~ Words Count ~*~---------
   Word Count .................... %d
   Characters (without Space) .... %d
   Characters (all) .............. %d
   Number of Lines ............... %d
   ANSCII Chars .................. %d
  %s
  =======================================
  "
      (+ (car list) (car (last list)))
      (cadr list)
      (- end start)
      (count-lines start end)
      (car (last list))
      (concat
       (unless (= 0 (car list))
         (format " Chinese Chars ................. %d\n"
                 (car list)))
       (format " English Words ................. %d\n"
               (count-words start end))))
     nil nil nil -1))

  ;;;###autoload
  (defun advance-words-count (beg end)
    "Chinese user preferred word count.
  If BEG = END, count the whole buffer. If called initeractively,
  use minibuffer to display the messages. The optional ARG will be
  passed to `message--words-count'.

  See also `special-words-count'."
    (interactive (if (use-region-p)
                     (list (region-beginning)
                           (region-end))
                   (list nil nil)))
    (let ((min (or beg (point-min)))
          (max (or end (point-max)))
          list)
      (setq list
            (mapcar
             (lambda (r) (special--words-count min max r))
             words-count-regexp-list))
      (if (called-interactively-p 'any)
          (message--words-count list min max)
        list)))
#+END_SRC
** Setup hideshow
#+BEGIN_SRC emacs-lisp
  (require 'hideshow)
  (add-hook 'prog-mode-hook 'hs-minor-mode)
  (defun hs-toggle-hiding-or-indent-for-tab-command (&optional arg)
    (interactive "P")
    (let ((oldpos (point)))
      (back-to-indentation)
      (if (hs-looking-at-block-start-p)
          (hs-toggle-hiding)
        (progn
          (goto-char oldpos)
          (indent-for-tab-command arg)))))
  (define-key hs-minor-mode-map (kbd "TAB") #'hs-toggle-hiding-or-indent-for-tab-command)
#+END_SRC
Make the overlay look nicer
#+BEGIN_SRC emacs-lisp
  (defconst hideshow-folded-face '((t (:inherit 'font-lock-comment-face :box t))))
  (defun hideshow-folded-overlay-fn (ov)
    (when (eq 'code (overlay-get ov 'hs))
      (let* ((nlines (count-lines (overlay-start ov) (overlay-end ov)))
             (info (format " ... #%d " nlines)))
        (overlay-put ov 'display (propertize info 'face hideshow-folded-face)))))
  (setq hs-set-up-overlay 'hideshow-folded-overlay-fn)
#+END_SRC

** Tramp
#+begin_src emacs-lisp
  (setq-default tramp-verbose 1)
#+end_src
** Enable disabled feature
#+begin_src emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
#+end_src
** Ivy-posframe

#+begin_src emacs-lisp :tangle no
  (init/ensure-package-lazy 'ivy-posframe)
  (ivy-posframe-mode 1)
  (setq ivy-posframe-parameters
        '((left-fringe . 8)
          (right-fringe . 8)))
  (setq posframe-mouse-banish-function #'posframe-mouse-banish-default)
  (with-eval-after-load 'ivy-posframe
    (with-current-buffer ivy-posframe-buffer
      (face-remap-add-relative 'fringe `(:background
                                         ,(face-background 'ivy-posframe)))))
#+end_src

Pin posfram to left-bottom

#+begin_src emacs-lisp :tangle no
  (setq ivy-posframe-display-functions-alist
        '((t . ivy-posframe-display-at-frame-bottom-left)))
#+end_src
** Telega
#+begin_src emacs-lisp
  (init/ensure-package-lazy 'telega)
  (if (bound-and-true-p init/local-proxies)
      (let ((http_proxy (cdr (assoc "http" init/local-proxies))))
        (if http_proxy
            (setq telega-proxies
                  (list
                   `(:server
                     ,(car (split-string http_proxy ":"))
                     :port
                     ,(string-to-number (cadr (split-string http_proxy ":")))
                     :enable t
                     :type (:@type "proxyTypeHttp")))))))
  (defun my-telega-chat-mode ()
    (add-hook 'completion-at-point-functions
              #'telega-chatbuf-complete-at-point nil 'local))
  (add-hook 'telega-chat-mode-hook 'my-telega-chat-mode)
#+end_src
** Wonderlust

#+begin_src emacs-lisp
  (init/ensure-package-lazy 'wanderlust)
  (if (boundp 'mail-user-agent)
      (setq mail-user-agent 'wl-user-agent))
  (if (fboundp 'define-mail-user-agent)
      (define-mail-user-agent
        'wl-user-agent
        'wl-user-agent-compose
        'wl-draft-send
        'wl-draft-kill
        'mail-send-hook))
#+end_src
** Vterm
#+begin_src emacs-lisp
  (init/ensure-package 'vterm)
  (define-key vterm-mode-map (kbd "C-y") 'vterm-send-C-S-v)
#+end_src
